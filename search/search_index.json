{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kamodo \u00b6 Kamodo is a CCMC tool for access, interpolation, and visualization of space weather models and data in python. Kamodo allows model developers to represent simulation results as mathematical functions which may be manipulated directly by end users. Kamodo handles unit conversion transparently and supports interactive science discovery through jupyter notebooks with minimal coding and is accessible through python. The project page is located at the Community Coordinated Modeling Center, located at NASA Goddard Space Flight Center. Official site page https://ccmc.gsfc.nasa.gov/Kamodo/ Kamodo's official source code is hosted on github under a permissive NASA open source license: https://github.com/nasa/Kamodo Periodic contributions to Kamodo are made from the unofficial repo located here https://github.com/asherp/Kamodo Usage \u00b6 Suppose we have a vector field defined by a function of positions in the x-y plane: from kamodo import kamodofy import numpy as np x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) @kamodofy ( units = 'km/s' ) def fvec ( rvec = points ): ux = np . sin ( rvec [:, 0 ]) uy = np . cos ( rvec [:, 1 ]) return np . vstack (( ux , uy )) . T The @kamodofy decorator lets us register this field with units to enable unit-conversion downstream: from kamodo import Kamodo kamodo = Kamodo ( fvec = fvec ) kamodo When run in a jupyter notebook, the above kamodo object will render as a set of equations: \\[\\vec{f}{\\left (\\vec{r} \\right )} [km/s] = \\lambda{\\left (\\vec{r} \\right )}\\] We can now evaluate our function using dot notation: kamodo . fvec ( np . array ([[ - 1 , 1 ]])) array([[-0.84147098, 0.54030231]]) We can perform unit conversion by function composition: kamodo [ 'gvec[m/s]' ] = 'fvec' kamodo automatically generates the appropriate multiplicative factors: \\( \\(\\vec{g}{\\left (\\vec{r} \\right )} [m/s] = 1000 \\vec{f}{\\left (\\vec{r} \\right )}\\) \\) we can verify these results through evaluation kamodo . gvec ( np . array ([[ - 1 , 1 ]])) array([[-841.47098481, 540.30230587]]) Kamodo also generates quick-look graphics via function inspection. import plotly.io as pio fig = kamodo . plot ( 'fvec' ) pio . write_image ( fig , 'images/fig2d-usage.svg' ) Head over to the Introduction page for more details. Getting started \u00b6 Kamodo may be installed from pip pip install kamodo Kamodo is now maintained by Ensemble Government Services. To get the latest version, install from the Ensemble git repo: pip install git+https://github.com/EnsembleGovServices/kamodo-core.git Kamodo Environment \u00b6 We strongly recommend using the conda environment system to avoid library conflicts with your host machine's python. Download and install miniconda from here . The advantage to using miniconda is that each new environment includes the bare-minimum for a project. This allows you to keep many different projects on a single work station. Create Kamodo environment \u00b6 Create a new environment for kamodo conda create -n kamodo python=3.7 conda activate kamodo (kamodo) pip install kamodo Note The leading (kamodo) in your prompt indicates that you have activated the kamodo environment. From here on, anything you install will be isolated to the kamodo environment. Loading example notebooks \u00b6 If you want to run any of the notebooks in docs, you will need to install jupyter : (kamodo) conda install jupyter Navigate to the top-level of the kamodo repo, then point jupyter to docs/notebooks : (kamodo) jupyter notebook docs/notebooks This should open a browser window that will allow you to load any of the example notebooks. Requirements \u00b6 The following (minimum) requirements are obtained by running pip install kamodo decorator>=4.4.2 numpy scipy sympy==1.5.1 pandas plotly pytest hydra-core==0.11.3 Flask==1.1.2 flask-cors flask-restful==0.3.8 antlr4-python3-runtime==4.7 python-forge requests incremental The antlr package may be necessary for rendering latex rendering in a notebook conda install antlr-python-runtime Plotly-orca may be needed for proper image export conda install -c plotly plotly-orca ( for writing images ) Note plotly version in flux Test Suite \u00b6 Kamodo's unit tests are run with pytest . To install pytest with code coverage python -m pip install flake8 pytest pip install pytest-cov Then, from the base of the git repo: pytest --cov kamodo.kamodo --cov kamodo.util --cov plotting kamodo/test_plotting.py kamodo/test_kamodo.py kamodo/test_utils.py This will generate a test report and coverage of the kamodo module. Generating Docs \u00b6 Kamodo's documentation site is a good example of how to embed your own plots in your own website. The documentation site is generated by the mkdocs package with some addons mkdocs - handles site generation and deployment (configured by top-level mkdocs.yaml ) markdown-include - allows for embedding of markdown files (and graph divs) outside the docs folder python-markdown-math - enables LaTeX rendering mknotebooks - allows for the embedding of jupyter notebooks All of the above requirements can be installed with this line: pip install mkdocs python-markdown-math markdown-include mknotebooks You can then generate the docs and serve locally with mkdocs serve To deploy your own documentation on github-pages: mkdocs gh-deploy This generates a gh-pages branch with the static site files and pushes it to github. Github automatically creates a website url based on that branch.","title":"Home"},{"location":"#kamodo","text":"Kamodo is a CCMC tool for access, interpolation, and visualization of space weather models and data in python. Kamodo allows model developers to represent simulation results as mathematical functions which may be manipulated directly by end users. Kamodo handles unit conversion transparently and supports interactive science discovery through jupyter notebooks with minimal coding and is accessible through python. The project page is located at the Community Coordinated Modeling Center, located at NASA Goddard Space Flight Center. Official site page https://ccmc.gsfc.nasa.gov/Kamodo/ Kamodo's official source code is hosted on github under a permissive NASA open source license: https://github.com/nasa/Kamodo Periodic contributions to Kamodo are made from the unofficial repo located here https://github.com/asherp/Kamodo","title":"Kamodo"},{"location":"#usage","text":"Suppose we have a vector field defined by a function of positions in the x-y plane: from kamodo import kamodofy import numpy as np x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) @kamodofy ( units = 'km/s' ) def fvec ( rvec = points ): ux = np . sin ( rvec [:, 0 ]) uy = np . cos ( rvec [:, 1 ]) return np . vstack (( ux , uy )) . T The @kamodofy decorator lets us register this field with units to enable unit-conversion downstream: from kamodo import Kamodo kamodo = Kamodo ( fvec = fvec ) kamodo When run in a jupyter notebook, the above kamodo object will render as a set of equations: \\[\\vec{f}{\\left (\\vec{r} \\right )} [km/s] = \\lambda{\\left (\\vec{r} \\right )}\\] We can now evaluate our function using dot notation: kamodo . fvec ( np . array ([[ - 1 , 1 ]])) array([[-0.84147098, 0.54030231]]) We can perform unit conversion by function composition: kamodo [ 'gvec[m/s]' ] = 'fvec' kamodo automatically generates the appropriate multiplicative factors: \\( \\(\\vec{g}{\\left (\\vec{r} \\right )} [m/s] = 1000 \\vec{f}{\\left (\\vec{r} \\right )}\\) \\) we can verify these results through evaluation kamodo . gvec ( np . array ([[ - 1 , 1 ]])) array([[-841.47098481, 540.30230587]]) Kamodo also generates quick-look graphics via function inspection. import plotly.io as pio fig = kamodo . plot ( 'fvec' ) pio . write_image ( fig , 'images/fig2d-usage.svg' ) Head over to the Introduction page for more details.","title":"Usage"},{"location":"#getting-started","text":"Kamodo may be installed from pip pip install kamodo Kamodo is now maintained by Ensemble Government Services. To get the latest version, install from the Ensemble git repo: pip install git+https://github.com/EnsembleGovServices/kamodo-core.git","title":"Getting started"},{"location":"#kamodo-environment","text":"We strongly recommend using the conda environment system to avoid library conflicts with your host machine's python. Download and install miniconda from here . The advantage to using miniconda is that each new environment includes the bare-minimum for a project. This allows you to keep many different projects on a single work station.","title":"Kamodo Environment"},{"location":"#create-kamodo-environment","text":"Create a new environment for kamodo conda create -n kamodo python=3.7 conda activate kamodo (kamodo) pip install kamodo Note The leading (kamodo) in your prompt indicates that you have activated the kamodo environment. From here on, anything you install will be isolated to the kamodo environment.","title":"Create Kamodo environment"},{"location":"#loading-example-notebooks","text":"If you want to run any of the notebooks in docs, you will need to install jupyter : (kamodo) conda install jupyter Navigate to the top-level of the kamodo repo, then point jupyter to docs/notebooks : (kamodo) jupyter notebook docs/notebooks This should open a browser window that will allow you to load any of the example notebooks.","title":"Loading example notebooks"},{"location":"#requirements","text":"The following (minimum) requirements are obtained by running pip install kamodo decorator>=4.4.2 numpy scipy sympy==1.5.1 pandas plotly pytest hydra-core==0.11.3 Flask==1.1.2 flask-cors flask-restful==0.3.8 antlr4-python3-runtime==4.7 python-forge requests incremental The antlr package may be necessary for rendering latex rendering in a notebook conda install antlr-python-runtime Plotly-orca may be needed for proper image export conda install -c plotly plotly-orca ( for writing images ) Note plotly version in flux","title":"Requirements"},{"location":"#test-suite","text":"Kamodo's unit tests are run with pytest . To install pytest with code coverage python -m pip install flake8 pytest pip install pytest-cov Then, from the base of the git repo: pytest --cov kamodo.kamodo --cov kamodo.util --cov plotting kamodo/test_plotting.py kamodo/test_kamodo.py kamodo/test_utils.py This will generate a test report and coverage of the kamodo module.","title":"Test Suite"},{"location":"#generating-docs","text":"Kamodo's documentation site is a good example of how to embed your own plots in your own website. The documentation site is generated by the mkdocs package with some addons mkdocs - handles site generation and deployment (configured by top-level mkdocs.yaml ) markdown-include - allows for embedding of markdown files (and graph divs) outside the docs folder python-markdown-math - enables LaTeX rendering mknotebooks - allows for the embedding of jupyter notebooks All of the above requirements can be installed with this line: pip install mkdocs python-markdown-math markdown-include mknotebooks You can then generate the docs and serve locally with mkdocs serve To deploy your own documentation on github-pages: mkdocs gh-deploy This generates a gh-pages branch with the static site files and pushes it to github. Github automatically creates a website url based on that branch.","title":"Generating Docs"},{"location":"API/","text":"API documentation \u00b6 Kamodo \u00b6 class kamodo. Kamodo ( *funcs , **kwargs ) Kamodo base class demonstrating common API for scientific resources. This API provides access to scientific fields and their properties through: Interpolation of variables at user-defined points Automatic unit conversions Function composition convenient for coordinate transformations and data pipelining Note: While intended for with space weather applications, the kamodo base class was designed to be as generic as possible, and should be applicable to a wide range of scientific domains and disciplines. Initialization \u00b6 class kamodo. Kamodo ( *funcs , **kwargs ) init ( self , *funcs , **kwargs ) Initialize Kamodo object with functions or by keyword Inputs funcs - (optional) list of expressions to register in f(x)=x format kwargs - (optional) key,value pairs of functions to register key - left-hand-side symbol value - can be one of: latex or python expression str e.g. \"x^2-x-1\" kamodofied function with appropriate .meta and .data attributers (see @kamodofy) lambda function (having no meta or data attributes) verbose - (optional) ( default=False ) flag to turn on all debugging print statements returns - dictionary-like kamodo object of (symbol, function) pairs usage: kobj = Kamodo ( 'f(x[cm])[kg/m^3]=x^2-x-1' , # full expressions with units area = kamodofy ( lambda x : x * x , units = 'cm^2' ), # kamodofied functions h = 'sin(x)' , # key-value expressions ) Registering functions \u00b6 class kamodo. Kamodo ( *funcs , **kwargs ) setitem ( self , sym_name , input_expr ) Assigns a function or expression to a new symbol, performing automatic function composition and inserting unit conversions where appropriate. sym_name - function symbol to associate with right-hand-side in one of the following formats: f - a lone fuction symbol (alphabetic argument ordering) f(z,x,y) - explicit argument ordering f[kg] - output unit assignment f(x[cm])[kg] - output and input unit assignment input_expr - rhs string or kamodofied function, one of: right-hand-side expression: python or latex str (e.g. x^2-x-1 ) kamodofied function with appropriate .meta and .data attributers (see @kamodofy) lambda function (having no meta or data attributes) Raises: - NameError when left-hand-side units incompatible with right-hand-side expression returns: None usage: Setting left-hand-side units will automatically trigger unit conversion kobj = Kamodo () kobj [ 'radius[m]' ] = 'r' kobj [ 'area[cm^2]' ] = 'pi * radius^2' kobj The above kobj will render in a Jupyter notebook like this: \\operatorname{radius}{\\left(r \\right)}[m] = r \\operatorname{area}{\\left(r \\right)}[cm^{2}] = 10000 \\pi \\operatorname{radius}^{2}{\\left(r \\right)} Kamodo will raise an error if left-hand-side units are incompatible with the right-hand-side expression kobj = Kamodo () kobj [ 'area[cm^2]' ] = 'x^2' # area has units of cm^2 try : kobj [ 'g(x)[kg]' ] = 'area' # mass not compatible with square length except NameError as m : print ( m ) output: \\text{cannot convert area(x) [centimeter**2] length**2 to g(x)[kilogram] mass} Retrieving functions \u00b6 Registered functions may be accessed via dictionary or attribute syntax. class kamodo. Kamodo ( *funcs , **kwargs ) getitem ( self , key ) Given a symbol string, retrieves the corresponding function. input: key - string or function symbol returns : the associated function usage : Rretrieval by function name: kobj [ 'f' ] = 'x^2-x-1' f = kobj [ 'f' ] f ( 3 ) # returns 5 It is also possible to retreive by function symbol: from kamodo import sympify fsymbol = sympify ( 'f' ) # converts str to symbol kobj [ 'f' ] = 'x^2-x-1' f = kobj [ fsymbol ] f ( 3 ) # returns 5 getattr ( self , name ) Retrieves a given function as an attribute. input - name of function to retrieve returns the associated function Usage: k = Kamodo ( f = 'x^2-x-1' ) k . f The above renders as follows in a jupyter notebook \\(f{\\left(x \\right)} = x^{2} - x - 1\\) Evaluation \u00b6 Function evaluation may be performed either by keyword or attribute syntax: k = Kamodo ( f = 'x^2-x-1' ) assert k . f ( 3 ) == k [ 'f' ]( 3 ) For closed-form expressions, kamodo uses the highly optimized numexpr library if available and will fall back to numpy otherwise: x = np . linspace ( - 5 , 5 , 33000111 ) k . f ( x ) Programmatic evaluation is also possible: class kamodo. Kamodo ( *funcs , **kwargs ) evaluate ( self , variable , *args , **kwargs ) Evaluate a given function variable using kwargs. If the variable is not present, try to parse it as an equation and evaluate the expression. inputs : variable - str: function string name to evaluate semicolon delmitted list of equations, the last of which will be evaluated args - not presently used kwargs - key-word arguments passed to function (required) returns : dictionary of input kwargs and output {variable: self.variable(**kwargs)} usage : k = Kamodo ( f = 'x+y' ) result = k . evaluate ( 'f' , x = 3 , y = 4 )[ 'f' ] assert k . f ( 3 , 4 ) == result assert k . evaluate ( 'g=f+3' , x = 3 , y = 4 )[ 'g' ] == result + 3 assert k . evaluate ( 'g=f+3;h=g+2' , x = 3 , y = 4 )[ 'h' ] == result + 3 + 2 Plotting \u00b6 single function plots \u00b6 For plotting single variables, the figure method is most appropriate class kamodo. Kamodo ( *funcs , **kwargs ) figure ( self , variable , indexing='ij' , **kwargs ) Generates a plotly figure for a single variable and keyword arguments inputs : variable: the name of a previously registered function kwargs: {arg: values} to pass to registered function indexing: determines order by which 2d matrices are given (affects contour_plot, carpet_plot, and plane) returns : plotly figure (dict-like) raises: SyntaxError if variable not found multi-function plots \u00b6 For multiple functions, the plot method is more convenient class kamodo. Kamodo ( *funcs , **kwargs ) plot ( self , *variables , plot_partial={} , **figures ) Generates a plotly figure from multiple variables and keyword arguments inputs : variable: the name of a previously registered function figures: dict {variable: {arg: values}} to pass to registered function returns : plotly figure (dict-like). When run in a jupyter notebook, an inline plotly figure will be displayed. raises : TypeError when required function arguments are not specified KeyError when no plotting function can be associated with input/output shapes usage : k = Kamodo ( f = lambda x = np . array ([ 2 , 3 , 4 ]): x ** 2 - x - 1 , g = 'sin(x)' ) k . plot ( 'f' ) # plots f using default arguments for f k . plot ( f = { x :[ 3 , 4 , 5 ]}, g = { x { - 2 , 3 , 4 }}) # plots f at x=[3,4,5] and g at [-2,3,4] LaTeX rendering \u00b6 The following methods allow Kamodo to integrate seemlessly with modern publication workflows. This includes support for LaTeX rendering within jupyter notebooks, LaTeX printing for manuscript preparation, and a high-level detail summary of registered functions. class kamodo. Kamodo ( *funcs , **kwargs ) repr_latex ( self ) Provides notebook rendering of kamodo object's registered functions. inputs - N/A returns latex string - obtained from to_latex method Usage: k = Kamodo ( f = 'x^2-x-1' ) k When placed on a line by itself, the above object will be rendered by jupyter notebooks like this: \\begin{equation}f{\\left(x \\right)} = x^{2} - x - 1\\end{equation} More on the repr_latex method can be found here Note: Registered functions are also equiped with their own repr_latex method. to_latex ( self , keys=None , mode='equation' ) Generate list of LaTeX-formated formulas inputs : keys - (optional) list(str) of registered functions to generate LaTeX from mode - (optional) string determines to wrap formulas 'equation' (default) wraps formulas in begin{equation} ... end{equation} 'inline': wraps formulas in dollar signs returns : LaTeX-formated string Note: This function does not need to be for rendering in jupyter. See repr_latex method. detail ( self ) Constructs a pandas dataframe from signatures inputs - N/A returns - pandas dataframe usage: k = Kamodo ( 'rho(x[cm])[g/cm^3]=x^2' , g = 'x+y' ) k . detail () outputs: symbol units lhs rhs arg_units rho rho(x) g/cm 3 rho(x) x 2 {'x': 'cm'} g g(x, y) g x + y {} Plotting \u00b6 Plot types \u00b6 As described in Visualization , Kamodo automatically maps registered functions to certain plot types. All such functions expect the same input variables and return a triplet [trace], chart_type, layout where [trace] is a list of plotly trace objects. kamodo.plotting. get_plot_types_df ( ) pack the plot types into a dataframe The available plot types may be imported thusly: from kamodo.plotting import plot_types Scatter plot \u00b6 kamodo.plotting. scatter_plot ( result , titles , verbose=False , **kwargs ) Generates a 3D scatter plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout Line plot \u00b6 kamodo.plotting. line_plot ( result , titles , verbose=False , **kwargs ) Generates a 1D, 2D or 3D line plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout Vector plot \u00b6 kamodo.plotting. vector_plot ( result , titles , verbose=False , **kwargs ) Generates a 2D or 3D vector plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout Contour plot \u00b6 kamodo.plotting. contour_plot ( result , titles , indexing , verbose=False , **kwargs ) Generates a 2D contour plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout 3D Plane \u00b6 kamodo.plotting. plane ( result , titles , indexing='xy' , verbose=False , **kwargs ) Generates a 3D plane plot. result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout 3D Surface \u00b6 kamodo.plotting. surface ( result , titles , verbose=False , **kwargs ) Generates a 3d surface-scalar or surface plot. result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout Carpet plot \u00b6 kamodo.plotting. carpet_plot ( results , title , xaxis , yaxis , indexing='xy' , **kwargs ) Generates a 2D skew (carpet) plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles xaxis: dictionary of {title: latex str} yaxis: dictionary of {title: latex str} indexing: str 'ij' or 'xy' determining array order kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot Triangulated Mesh plot \u00b6 kamodo.plotting. tri_surface_plot ( result , titles , verbose=False , **kwargs ) Generates a 3D mesh (tri-surface) plot. result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout Image plot \u00b6 kamodo.plotting. image ( result , titles , verbose=False , **kwargs ) Generates a 2D image plot result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout Decorators \u00b6 These decorators may also be imported like this from kamodo import kamodofy kamodofy \u00b6 kamodo.util. kamodofy ( _func=None , units='' , arg_units=None , data=None , update=None , equation=None , citation=None , hidden_args=[] , **kwargs ) Adds meta and data attributes to functions for registering with Komodo objects. inputs : _func: function to wrap units: (optional) physical output units arg_units: (optional) dictionary { arg : str unit} containing physical input units data: if supplied, set f.data = data, if not supplied, set f.data = f(), assuming it can be called with no arguments. If f cannot be called with no arguments, will set f.data = None update: name of another function's argument to update (see simulation api ) equation: str representing right-hand-side of the function citation: str reference for publication hidden_args: arguments of function to hide from latex rendering kwargs: other key word arguments returns : the decorated function with the following attributes meta is a dictionary containing units: physical output units (str) arg_units: dictionary { arg : str unit} equation: latex str representing right-hand-side of the function citation: str reference for publication hidden: str list of arguments to hide from latex rendering data: default data representing expected function output for default arguments update: name of another function's argument to update usage : @kamodofy ( units = 'kg/cm^2' , arg_units = dict ( x = 'cm' ), citation = 'Pembroke et. al 2022' , hidden_args = [ 'verbose' ]) def myfunc ( x = 30 , verbose = True ): return x ** 2 myfunc . meta {'units': 'kg/cm^2', 'arg_units': {'x': 'cm'}, 'citation': 'Pembroke et. al 2022', 'equation': None, 'hidden_args': ['verbose']} The above metadata is used by Kamodo objects for function registration. Similarly, a data attribute is attached which represents the output of the function when called with no arguments: myfunc . data 900 kamodo.util. gridify ( _func=None , order='A' , squeeze=True , **defaults ) Given a function of shape (n,dim) and arguments of shape (L), (M), calls f with points L*M _func: kamodo function order: 'A' (default) uses indexing='xy' in meshgrid, 'C' uses indexing='ij' in meshgrid squeeze: True (default) passed to reshape before returning returns: decorator gridify pointlike \u00b6 kamodo.util. pointlike ( _func=None , signature=None , otypes=[ ] , squeeze=None ) Transforms a single-argument function to one that accepts m points of dimension n _func: kamodo function returns: decorator pointlike partial \u00b6 kamodo.util. partial ( _func=None , **partial_kwargs ) A partial function decorator, Reduces function signature to reflect partially assigned kwargs _func: kamodo function object **partial_kwargs: returns: decorator partial Test Suite \u00b6 Kamodo features a full suite of tests run via pytest. We highlight a few of these tests below as further examples of Kamodo's expected use cases. Kamodo Tests \u00b6 kamodo.test_kamodo. test_Kamodo_expr ( ) Method for testing correctness of expression. kamodo.test_kamodo. test_Kamodo_latex ( ) Method for testing latex representation of expression. kamodo.test_kamodo. test_Kamodo_mismatched_symbols ( ) Method for testing symobls in accroding expression. kamodo.test_kamodo. test_Kamodo_reassignment ( ) Method for testing reassignment of expression. kamodo.test_kamodo. test_function_registry ( ) Method for testing kamodo's function registry. kamodo.test_kamodo. test_unit_registry ( ) Method for testing kamodo function's unit registry kamodo.test_kamodo. test_komodofy_decorator ( ) Method for testing kamodofy dcorator. kamodo.test_kamodo. test_vectorize ( ) Method for testing vetorization of expression. kamodo.test_kamodo. test_jit_evaluate ( ) Kamodo testing method for just-in time evaluation. kamodo.test_kamodo. test_multiple_traces ( ) Method for testing multiple traces in a figure. Plotting Tests \u00b6 kamodo.test_plotting. test_scatter_plot ( ) Method for testing scatter plot's trace, layout and plot type. kamodo.test_plotting. test_line_plot_line ( ) Method for testing line plot's trace, layout and plot type. kamodo.test_plotting. test_line_plot_2d_line ( ) Method for testing 2D line plot's trace, layout and plot type. kamodo.test_plotting. test_line_plot_3d_line_pd ( ) Method for testing 3D line plot's trace, layout and plot type. kamodo.test_plotting. test_vector_plot_2d_vector ( ) Method for testing 2D vector plot's trace, layout and plot type. kamodo.test_plotting. test_vector_plot_3d_vector ( ) Method for testing 3D vector plot's trace, layout and plot type. kamodo.test_plotting. test_vector_plot_3d_vector ( ) Method for testing 3D vector plot's trace, layout and plot type. kamodo.test_plotting. test_contour_plot_2d_grid ( ) Method for testing 2D contour plot's trace, layout and plot type. kamodo.test_plotting. test_contour_plot_2d_skew ( ) Method for testing 2D skew plot's trace, layout and plot type. kamodo.test_plotting. test_plane ( ) Method for testing plane plot's trace, layout and plot type. kamodo.test_plotting. test_surface_3d_surface ( ) Method for testing 3D surface plot's trace, layout and plot type. kamodo.test_plotting. test_arg_shape_pd ( ) Method for testing argument shape. kamodo.test_plotting. test_image_plot ( ) Method for testing image plot's trace, layout and plot type.","title":"API"},{"location":"API/#api-documentation","text":"","title":"API documentation"},{"location":"API/#kamodo","text":"class kamodo. Kamodo ( *funcs , **kwargs ) Kamodo base class demonstrating common API for scientific resources. This API provides access to scientific fields and their properties through: Interpolation of variables at user-defined points Automatic unit conversions Function composition convenient for coordinate transformations and data pipelining Note: While intended for with space weather applications, the kamodo base class was designed to be as generic as possible, and should be applicable to a wide range of scientific domains and disciplines.","title":"Kamodo"},{"location":"API/#initialization","text":"class kamodo. Kamodo ( *funcs , **kwargs ) init ( self , *funcs , **kwargs ) Initialize Kamodo object with functions or by keyword Inputs funcs - (optional) list of expressions to register in f(x)=x format kwargs - (optional) key,value pairs of functions to register key - left-hand-side symbol value - can be one of: latex or python expression str e.g. \"x^2-x-1\" kamodofied function with appropriate .meta and .data attributers (see @kamodofy) lambda function (having no meta or data attributes) verbose - (optional) ( default=False ) flag to turn on all debugging print statements returns - dictionary-like kamodo object of (symbol, function) pairs usage: kobj = Kamodo ( 'f(x[cm])[kg/m^3]=x^2-x-1' , # full expressions with units area = kamodofy ( lambda x : x * x , units = 'cm^2' ), # kamodofied functions h = 'sin(x)' , # key-value expressions )","title":"Initialization"},{"location":"API/#registering-functions","text":"class kamodo. Kamodo ( *funcs , **kwargs ) setitem ( self , sym_name , input_expr ) Assigns a function or expression to a new symbol, performing automatic function composition and inserting unit conversions where appropriate. sym_name - function symbol to associate with right-hand-side in one of the following formats: f - a lone fuction symbol (alphabetic argument ordering) f(z,x,y) - explicit argument ordering f[kg] - output unit assignment f(x[cm])[kg] - output and input unit assignment input_expr - rhs string or kamodofied function, one of: right-hand-side expression: python or latex str (e.g. x^2-x-1 ) kamodofied function with appropriate .meta and .data attributers (see @kamodofy) lambda function (having no meta or data attributes) Raises: - NameError when left-hand-side units incompatible with right-hand-side expression returns: None usage: Setting left-hand-side units will automatically trigger unit conversion kobj = Kamodo () kobj [ 'radius[m]' ] = 'r' kobj [ 'area[cm^2]' ] = 'pi * radius^2' kobj The above kobj will render in a Jupyter notebook like this: \\operatorname{radius}{\\left(r \\right)}[m] = r \\operatorname{area}{\\left(r \\right)}[cm^{2}] = 10000 \\pi \\operatorname{radius}^{2}{\\left(r \\right)} Kamodo will raise an error if left-hand-side units are incompatible with the right-hand-side expression kobj = Kamodo () kobj [ 'area[cm^2]' ] = 'x^2' # area has units of cm^2 try : kobj [ 'g(x)[kg]' ] = 'area' # mass not compatible with square length except NameError as m : print ( m ) output: \\text{cannot convert area(x) [centimeter**2] length**2 to g(x)[kilogram] mass}","title":"Registering functions"},{"location":"API/#retrieving-functions","text":"Registered functions may be accessed via dictionary or attribute syntax. class kamodo. Kamodo ( *funcs , **kwargs ) getitem ( self , key ) Given a symbol string, retrieves the corresponding function. input: key - string or function symbol returns : the associated function usage : Rretrieval by function name: kobj [ 'f' ] = 'x^2-x-1' f = kobj [ 'f' ] f ( 3 ) # returns 5 It is also possible to retreive by function symbol: from kamodo import sympify fsymbol = sympify ( 'f' ) # converts str to symbol kobj [ 'f' ] = 'x^2-x-1' f = kobj [ fsymbol ] f ( 3 ) # returns 5 getattr ( self , name ) Retrieves a given function as an attribute. input - name of function to retrieve returns the associated function Usage: k = Kamodo ( f = 'x^2-x-1' ) k . f The above renders as follows in a jupyter notebook \\(f{\\left(x \\right)} = x^{2} - x - 1\\)","title":"Retrieving functions"},{"location":"API/#evaluation","text":"Function evaluation may be performed either by keyword or attribute syntax: k = Kamodo ( f = 'x^2-x-1' ) assert k . f ( 3 ) == k [ 'f' ]( 3 ) For closed-form expressions, kamodo uses the highly optimized numexpr library if available and will fall back to numpy otherwise: x = np . linspace ( - 5 , 5 , 33000111 ) k . f ( x ) Programmatic evaluation is also possible: class kamodo. Kamodo ( *funcs , **kwargs ) evaluate ( self , variable , *args , **kwargs ) Evaluate a given function variable using kwargs. If the variable is not present, try to parse it as an equation and evaluate the expression. inputs : variable - str: function string name to evaluate semicolon delmitted list of equations, the last of which will be evaluated args - not presently used kwargs - key-word arguments passed to function (required) returns : dictionary of input kwargs and output {variable: self.variable(**kwargs)} usage : k = Kamodo ( f = 'x+y' ) result = k . evaluate ( 'f' , x = 3 , y = 4 )[ 'f' ] assert k . f ( 3 , 4 ) == result assert k . evaluate ( 'g=f+3' , x = 3 , y = 4 )[ 'g' ] == result + 3 assert k . evaluate ( 'g=f+3;h=g+2' , x = 3 , y = 4 )[ 'h' ] == result + 3 + 2","title":"Evaluation"},{"location":"API/#plotting","text":"","title":"Plotting"},{"location":"API/#single-function-plots","text":"For plotting single variables, the figure method is most appropriate class kamodo. Kamodo ( *funcs , **kwargs ) figure ( self , variable , indexing='ij' , **kwargs ) Generates a plotly figure for a single variable and keyword arguments inputs : variable: the name of a previously registered function kwargs: {arg: values} to pass to registered function indexing: determines order by which 2d matrices are given (affects contour_plot, carpet_plot, and plane) returns : plotly figure (dict-like) raises: SyntaxError if variable not found","title":"single function plots"},{"location":"API/#multi-function-plots","text":"For multiple functions, the plot method is more convenient class kamodo. Kamodo ( *funcs , **kwargs ) plot ( self , *variables , plot_partial={} , **figures ) Generates a plotly figure from multiple variables and keyword arguments inputs : variable: the name of a previously registered function figures: dict {variable: {arg: values}} to pass to registered function returns : plotly figure (dict-like). When run in a jupyter notebook, an inline plotly figure will be displayed. raises : TypeError when required function arguments are not specified KeyError when no plotting function can be associated with input/output shapes usage : k = Kamodo ( f = lambda x = np . array ([ 2 , 3 , 4 ]): x ** 2 - x - 1 , g = 'sin(x)' ) k . plot ( 'f' ) # plots f using default arguments for f k . plot ( f = { x :[ 3 , 4 , 5 ]}, g = { x { - 2 , 3 , 4 }}) # plots f at x=[3,4,5] and g at [-2,3,4]","title":"multi-function plots"},{"location":"API/#latex-rendering","text":"The following methods allow Kamodo to integrate seemlessly with modern publication workflows. This includes support for LaTeX rendering within jupyter notebooks, LaTeX printing for manuscript preparation, and a high-level detail summary of registered functions. class kamodo. Kamodo ( *funcs , **kwargs ) repr_latex ( self ) Provides notebook rendering of kamodo object's registered functions. inputs - N/A returns latex string - obtained from to_latex method Usage: k = Kamodo ( f = 'x^2-x-1' ) k When placed on a line by itself, the above object will be rendered by jupyter notebooks like this: \\begin{equation}f{\\left(x \\right)} = x^{2} - x - 1\\end{equation} More on the repr_latex method can be found here Note: Registered functions are also equiped with their own repr_latex method. to_latex ( self , keys=None , mode='equation' ) Generate list of LaTeX-formated formulas inputs : keys - (optional) list(str) of registered functions to generate LaTeX from mode - (optional) string determines to wrap formulas 'equation' (default) wraps formulas in begin{equation} ... end{equation} 'inline': wraps formulas in dollar signs returns : LaTeX-formated string Note: This function does not need to be for rendering in jupyter. See repr_latex method. detail ( self ) Constructs a pandas dataframe from signatures inputs - N/A returns - pandas dataframe usage: k = Kamodo ( 'rho(x[cm])[g/cm^3]=x^2' , g = 'x+y' ) k . detail () outputs: symbol units lhs rhs arg_units rho rho(x) g/cm 3 rho(x) x 2 {'x': 'cm'} g g(x, y) g x + y {}","title":"LaTeX rendering"},{"location":"API/#plotting_1","text":"","title":"Plotting"},{"location":"API/#plot-types","text":"As described in Visualization , Kamodo automatically maps registered functions to certain plot types. All such functions expect the same input variables and return a triplet [trace], chart_type, layout where [trace] is a list of plotly trace objects. kamodo.plotting. get_plot_types_df ( ) pack the plot types into a dataframe The available plot types may be imported thusly: from kamodo.plotting import plot_types","title":"Plot types"},{"location":"API/#scatter-plot","text":"kamodo.plotting. scatter_plot ( result , titles , verbose=False , **kwargs ) Generates a 3D scatter plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"Scatter plot"},{"location":"API/#line-plot","text":"kamodo.plotting. line_plot ( result , titles , verbose=False , **kwargs ) Generates a 1D, 2D or 3D line plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"Line plot"},{"location":"API/#vector-plot","text":"kamodo.plotting. vector_plot ( result , titles , verbose=False , **kwargs ) Generates a 2D or 3D vector plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"Vector plot"},{"location":"API/#contour-plot","text":"kamodo.plotting. contour_plot ( result , titles , indexing , verbose=False , **kwargs ) Generates a 2D contour plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"Contour plot"},{"location":"API/#3d-plane","text":"kamodo.plotting. plane ( result , titles , indexing='xy' , verbose=False , **kwargs ) Generates a 3D plane plot. result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"3D Plane"},{"location":"API/#3d-surface","text":"kamodo.plotting. surface ( result , titles , verbose=False , **kwargs ) Generates a 3d surface-scalar or surface plot. result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"3D Surface"},{"location":"API/#carpet-plot","text":"kamodo.plotting. carpet_plot ( results , title , xaxis , yaxis , indexing='xy' , **kwargs ) Generates a 2D skew (carpet) plot. inputs : result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles xaxis: dictionary of {title: latex str} yaxis: dictionary of {title: latex str} indexing: str 'ij' or 'xy' determining array order kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot","title":"Carpet plot"},{"location":"API/#triangulated-mesh-plot","text":"kamodo.plotting. tri_surface_plot ( result , titles , verbose=False , **kwargs ) Generates a 3D mesh (tri-surface) plot. result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"Triangulated Mesh plot"},{"location":"API/#image-plot","text":"kamodo.plotting. image ( result , titles , verbose=False , **kwargs ) Generates a 2D image plot result: dictionary returned by Kamodo().evaluate titles: dictionary holding plot titles indexing: str 'ij' or 'xy' determining array order verbose: boolean (default False) for debugging kwargs: additional arguments specific to plot types returns - tuple: traces - list of plotly trace objects chart_type - str name of this type of plot layout - dict-like plotly layout","title":"Image plot"},{"location":"API/#decorators","text":"These decorators may also be imported like this from kamodo import kamodofy","title":"Decorators"},{"location":"API/#kamodofy","text":"kamodo.util. kamodofy ( _func=None , units='' , arg_units=None , data=None , update=None , equation=None , citation=None , hidden_args=[] , **kwargs ) Adds meta and data attributes to functions for registering with Komodo objects. inputs : _func: function to wrap units: (optional) physical output units arg_units: (optional) dictionary { arg : str unit} containing physical input units data: if supplied, set f.data = data, if not supplied, set f.data = f(), assuming it can be called with no arguments. If f cannot be called with no arguments, will set f.data = None update: name of another function's argument to update (see simulation api ) equation: str representing right-hand-side of the function citation: str reference for publication hidden_args: arguments of function to hide from latex rendering kwargs: other key word arguments returns : the decorated function with the following attributes meta is a dictionary containing units: physical output units (str) arg_units: dictionary { arg : str unit} equation: latex str representing right-hand-side of the function citation: str reference for publication hidden: str list of arguments to hide from latex rendering data: default data representing expected function output for default arguments update: name of another function's argument to update usage : @kamodofy ( units = 'kg/cm^2' , arg_units = dict ( x = 'cm' ), citation = 'Pembroke et. al 2022' , hidden_args = [ 'verbose' ]) def myfunc ( x = 30 , verbose = True ): return x ** 2 myfunc . meta {'units': 'kg/cm^2', 'arg_units': {'x': 'cm'}, 'citation': 'Pembroke et. al 2022', 'equation': None, 'hidden_args': ['verbose']} The above metadata is used by Kamodo objects for function registration. Similarly, a data attribute is attached which represents the output of the function when called with no arguments: myfunc . data 900 kamodo.util. gridify ( _func=None , order='A' , squeeze=True , **defaults ) Given a function of shape (n,dim) and arguments of shape (L), (M), calls f with points L*M _func: kamodo function order: 'A' (default) uses indexing='xy' in meshgrid, 'C' uses indexing='ij' in meshgrid squeeze: True (default) passed to reshape before returning returns: decorator gridify","title":"kamodofy"},{"location":"API/#pointlike","text":"kamodo.util. pointlike ( _func=None , signature=None , otypes=[ ] , squeeze=None ) Transforms a single-argument function to one that accepts m points of dimension n _func: kamodo function returns: decorator pointlike","title":"pointlike"},{"location":"API/#partial","text":"kamodo.util. partial ( _func=None , **partial_kwargs ) A partial function decorator, Reduces function signature to reflect partially assigned kwargs _func: kamodo function object **partial_kwargs: returns: decorator partial","title":"partial"},{"location":"API/#test-suite","text":"Kamodo features a full suite of tests run via pytest. We highlight a few of these tests below as further examples of Kamodo's expected use cases.","title":"Test Suite"},{"location":"API/#kamodo-tests","text":"kamodo.test_kamodo. test_Kamodo_expr ( ) Method for testing correctness of expression. kamodo.test_kamodo. test_Kamodo_latex ( ) Method for testing latex representation of expression. kamodo.test_kamodo. test_Kamodo_mismatched_symbols ( ) Method for testing symobls in accroding expression. kamodo.test_kamodo. test_Kamodo_reassignment ( ) Method for testing reassignment of expression. kamodo.test_kamodo. test_function_registry ( ) Method for testing kamodo's function registry. kamodo.test_kamodo. test_unit_registry ( ) Method for testing kamodo function's unit registry kamodo.test_kamodo. test_komodofy_decorator ( ) Method for testing kamodofy dcorator. kamodo.test_kamodo. test_vectorize ( ) Method for testing vetorization of expression. kamodo.test_kamodo. test_jit_evaluate ( ) Kamodo testing method for just-in time evaluation. kamodo.test_kamodo. test_multiple_traces ( ) Method for testing multiple traces in a figure.","title":"Kamodo Tests"},{"location":"API/#plotting-tests","text":"kamodo.test_plotting. test_scatter_plot ( ) Method for testing scatter plot's trace, layout and plot type. kamodo.test_plotting. test_line_plot_line ( ) Method for testing line plot's trace, layout and plot type. kamodo.test_plotting. test_line_plot_2d_line ( ) Method for testing 2D line plot's trace, layout and plot type. kamodo.test_plotting. test_line_plot_3d_line_pd ( ) Method for testing 3D line plot's trace, layout and plot type. kamodo.test_plotting. test_vector_plot_2d_vector ( ) Method for testing 2D vector plot's trace, layout and plot type. kamodo.test_plotting. test_vector_plot_3d_vector ( ) Method for testing 3D vector plot's trace, layout and plot type. kamodo.test_plotting. test_vector_plot_3d_vector ( ) Method for testing 3D vector plot's trace, layout and plot type. kamodo.test_plotting. test_contour_plot_2d_grid ( ) Method for testing 2D contour plot's trace, layout and plot type. kamodo.test_plotting. test_contour_plot_2d_skew ( ) Method for testing 2D skew plot's trace, layout and plot type. kamodo.test_plotting. test_plane ( ) Method for testing plane plot's trace, layout and plot type. kamodo.test_plotting. test_surface_3d_surface ( ) Method for testing 3D surface plot's trace, layout and plot type. kamodo.test_plotting. test_arg_shape_pd ( ) Method for testing argument shape. kamodo.test_plotting. test_image_plot ( ) Method for testing image plot's trace, layout and plot type.","title":"Plotting Tests"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 Creating Issues \u00b6 For bugs, open an issue following this guide . For features, provide enough context to illustrate the intended use case. If possible, include a test function that should pass once the feature is considered complete. Developer setup \u00b6 Clone the git repo and install kamodo in developer mode: from the base of the repo: pip install -e . Note If you add any files while in editor mode, make sure they will be picked up by the MANIFEST.in file. Kamodo is cross-platform, so you should be able work on whatever developing environment is convenient for you. However, we find it helpful to mount the code into a docker container and we provide a docker-compose.yaml. This causes the least disruption with your machine and makes it easier to deploy Kamodo containers to cloud services. If you have installed docker with docker compose , you can spin up a developer environment with one line from the base of the repo: docker compose up Creating a Pull Request \u00b6 Want to contribute to Kamodo-core? Open a pull request! Branching \u00b6 First create a branch off of master , named after the feature or issue you are targeting. git checkout -b issue-999 You may start your PR when you prefer, depending on how much support you'll need to complete it, but remember it should be up-to-date with master before it can be merged. Testing \u00b6 Run tests locally prior to pushing. python -m pip install flake8 pytest pip install pytest-cov Then, from the base of the git repo pytest --cov kamodo.kamodo --cov kamodo.util --cov plotting kamodo/test_plotting.py kamodo/test_kamodo.py kamodo/test_utils.py Try to at least maintain the current code coverage with your PR. Hourly (optional) \u00b6 Consider using hourly for time tracking your branch. This will allow future developers to see which parts of the code receive the most attention. If you're using hourly, you'll want to configure hourly.yaml so that your worklog points to a file named after you: work_log : header_depth : 3 filename : worklogs/my_github_username.md","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"","title":"Contributing"},{"location":"CONTRIBUTING/#creating-issues","text":"For bugs, open an issue following this guide . For features, provide enough context to illustrate the intended use case. If possible, include a test function that should pass once the feature is considered complete.","title":"Creating Issues"},{"location":"CONTRIBUTING/#developer-setup","text":"Clone the git repo and install kamodo in developer mode: from the base of the repo: pip install -e . Note If you add any files while in editor mode, make sure they will be picked up by the MANIFEST.in file. Kamodo is cross-platform, so you should be able work on whatever developing environment is convenient for you. However, we find it helpful to mount the code into a docker container and we provide a docker-compose.yaml. This causes the least disruption with your machine and makes it easier to deploy Kamodo containers to cloud services. If you have installed docker with docker compose , you can spin up a developer environment with one line from the base of the repo: docker compose up","title":"Developer setup"},{"location":"CONTRIBUTING/#creating-a-pull-request","text":"Want to contribute to Kamodo-core? Open a pull request!","title":"Creating a Pull Request"},{"location":"CONTRIBUTING/#branching","text":"First create a branch off of master , named after the feature or issue you are targeting. git checkout -b issue-999 You may start your PR when you prefer, depending on how much support you'll need to complete it, but remember it should be up-to-date with master before it can be merged.","title":"Branching"},{"location":"CONTRIBUTING/#testing","text":"Run tests locally prior to pushing. python -m pip install flake8 pytest pip install pytest-cov Then, from the base of the git repo pytest --cov kamodo.kamodo --cov kamodo.util --cov plotting kamodo/test_plotting.py kamodo/test_kamodo.py kamodo/test_utils.py Try to at least maintain the current code coverage with your PR.","title":"Testing"},{"location":"CONTRIBUTING/#hourly-optional","text":"Consider using hourly for time tracking your branch. This will allow future developers to see which parts of the code receive the most attention. If you're using hourly, you'll want to configure hourly.yaml so that your worklog points to a file named after you: work_log : header_depth : 3 filename : worklogs/my_github_username.md","title":"Hourly (optional)"},{"location":"about/","text":"About Kamodo \u00b6 Kamodo has been under development at the Community Coordinated Modeling Center (CCMC), NASA GSFC since May, 2018. The CCMC supports the space weather community by providing software and services guided by domain experts in a variety of heliophysic science domains. Kamodo supports the goals of the CCMC by: Bringing together models and data into a single high-level mathematical framework Allows scientists and educators to work with complex space weather models and data with little or no coding experience Provides an easy-to-extend framework for developers. Kameleon legacy \u00b6 Kamodo shares some similarities with its predecessor, the CCMC's Kameleon Software Suite, insofaras it provides a unified API for space weather models. However, Kamodo gets there through a very different means: by leveraging cutting-edge python projects from both the heliophysics community (sunpy, spacepy, etc.) as well as more general mathematical frameworks like sympy. This allows Kamodo to be much more broad in its application, able to handle arbirtary scientific data and physics-based models. At the same time, by building on the tools provided by model and data providers, Kamodo inherits the high performance necessary for data analysis. We felt that due to the large departure in both design and scope from Kameleon, it was necessary to launch Kamodo as a separate project under a different moniker. Design philosophy \u00b6 Primary Design considerations Open Source (Apache 2.0) Should be format-, model-, data-agnostic Should support all types of users (non-coders, devs, modelers). Anyone can cook! Carrot approach to metadata (useful, but not mandatory)","title":"About"},{"location":"about/#about-kamodo","text":"Kamodo has been under development at the Community Coordinated Modeling Center (CCMC), NASA GSFC since May, 2018. The CCMC supports the space weather community by providing software and services guided by domain experts in a variety of heliophysic science domains. Kamodo supports the goals of the CCMC by: Bringing together models and data into a single high-level mathematical framework Allows scientists and educators to work with complex space weather models and data with little or no coding experience Provides an easy-to-extend framework for developers.","title":"About Kamodo"},{"location":"about/#kameleon-legacy","text":"Kamodo shares some similarities with its predecessor, the CCMC's Kameleon Software Suite, insofaras it provides a unified API for space weather models. However, Kamodo gets there through a very different means: by leveraging cutting-edge python projects from both the heliophysics community (sunpy, spacepy, etc.) as well as more general mathematical frameworks like sympy. This allows Kamodo to be much more broad in its application, able to handle arbirtary scientific data and physics-based models. At the same time, by building on the tools provided by model and data providers, Kamodo inherits the high performance necessary for data analysis. We felt that due to the large departure in both design and scope from Kameleon, it was necessary to launch Kamodo as a separate project under a different moniker.","title":"Kameleon legacy"},{"location":"about/#design-philosophy","text":"Primary Design considerations Open Source (Apache 2.0) Should be format-, model-, data-agnostic Should support all types of users (non-coders, devs, modelers). Anyone can cook! Carrot approach to metadata (useful, but not mandatory)","title":"Design philosophy"},{"location":"additional_resources/","text":"Additional Resources \u00b6 Examples of using Numpy f2py to compile Fortran code into importable Python modules: https://www.scivision.dev/f2py-running-fortran-code-in-python-on-windows/ https://github.com/scivision/f2py-examples Tutorial: Using Fortran from Python http://arogozhnikov.github.io/2015/11/29/using-fortran-from-python.html See Prototypes/Fortran2Python_example.ipynb for details Numpy documentation for f2py https://docs.scipy.org/doc/numpy/f2py/python-usage.html","title":"Additional Resources"},{"location":"additional_resources/#additional-resources","text":"Examples of using Numpy f2py to compile Fortran code into importable Python modules: https://www.scivision.dev/f2py-running-fortran-code-in-python-on-windows/ https://github.com/scivision/f2py-examples Tutorial: Using Fortran from Python http://arogozhnikov.github.io/2015/11/29/using-fortran-from-python.html See Prototypes/Fortran2Python_example.ipynb for details Numpy documentation for f2py https://docs.scipy.org/doc/numpy/f2py/python-usage.html","title":"Additional Resources"},{"location":"notebooks/CommandLineInterface/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Kamodo-CLI \u00b6 The kamodo command-line interface should be installed automatically with pip pip install kamodo Warning The command line app is a work in progress. Expect changes! Note You can run these examples in a notebook with !kamodo Run the command line interface with kamodo <key>.<subkey>=value instantiation \u00b6 To create a simple function ready for evaluation: kamodo model.params.f[cm]=x**2 lhs rhs symbol units f(x) f x**2 f(x) cm \\begin{equation}f{\\left(x \\right)} [cm] = x^{2}\\end{equation} Kamodo will print a description of the loaded model when verbose output is on (the default). evaluation \u00b6 To evaluate a model, provide arguments for each function. kamodo model.params.f[cm]=x**2 model.evaluate.f.x=[-3,-1,1,3] verbose=false f(x=[-3, -1, 1, 3]) cm = [9 1 1 9] visualization \u00b6 To visualize model output, provide plot parameters similar to evaluation kamodo model.params.f[cm]=x**2 model.plot.f.x.min=-2 model.plot.f.x.max=2 model.plot.f.x.n=25 verbose=False An interactive plot will open with your figure Kamodofied models \u00b6 To work with a kamodofied model, specify the model.class . kamodo model.class=kamodo.readers.tiegcm.TIEGCM_Kamodo model.params.filename=$PWD/s001.nc model.plot.EFLUX.lon=[0] Configuration \u00b6 Kamodo can use configuration files so that arguments do not have to be passed manually. To create your own configuration, create a config.yaml file in your project's directory: config_override : kamodo.yaml gui : external_stylesheets : [] routes_pathname_prefix : /kamodo/ kamodo_output : kamodo_output models : mymodel : class : kamodo.Kamodo evaluate : {} fig_layout : autosize : true params : f : x**2 - 1 y : f**3 plot : f : x : max : 1 min : -1 n : 31 y : x : max : 1 min : -1 n : 31 myothermodel : class : kamodo.Kamodo evaluate : {} fig_layout : autosize : true params : f : x**3 g : y - x mythirdmodel : class : kamodo.test_kamodo.Ktest user_model : class : kamodo.test_kamodo.Ktest plot_conf : animation_opts : null auto_open : true auto_play : true config : null filename : temp-plot.html image : null image_filename : plot_image include_mathjax : cdn include_plotlyjs : cdn link_text : Export to plot.ly output_type : file show_link : false validate : true verbose : true Running kamodo from a directory containing the above config.yaml will produce the same plot as before: ! kamodo mymodel Empty DataFrame Columns: [] Index: [] Empty DataFrame Columns: [] Index: [] Configuration Priority \u00b6 Kamodo is built on hydra, which prioritizes configuration using the following rules: If there are two configurations that define the same value, the second one would win. If two configurations are contributing to the same dictionary the result would be the combined dictionary. Help \u00b6 kamodo --help A low-coding command line interface for Kamodo This application allows users to work with kamodo-compatible models and data directly from the command line. Custom models, data, and expressions may be composed by editing config files without needing to write python. == Configuration groups == Compose your configuration from those groups (group=option) == Config == Override anything in the config (foo.bar=value) model: class: kamodo.Kamodo evaluate: {} fig_layout: {} params: {} plot: {} plot_conf: animation_opts: null auto_open: true auto_play: true config: null filename: temp-plot.html image: null image_filename: plot_image include_mathjax: cdn include_plotlyjs: true link_text: Export to plot.ly output_type: file show_link: false validate: true verbose: true Powered by Hydra (https://hydra.cc) Use --hydra-help to view Hydra specific help tab completion \u00b6 Kamodo supports tab completion for bash. To set up bash tab completion, run the following: eval \"$(kamodo -sc install=bash)\"","title":"CommandLineInterface"},{"location":"notebooks/CommandLineInterface/#kamodo-cli","text":"The kamodo command-line interface should be installed automatically with pip pip install kamodo Warning The command line app is a work in progress. Expect changes! Note You can run these examples in a notebook with !kamodo Run the command line interface with kamodo <key>.<subkey>=value","title":"Kamodo-CLI"},{"location":"notebooks/CommandLineInterface/#instantiation","text":"To create a simple function ready for evaluation: kamodo model.params.f[cm]=x**2 lhs rhs symbol units f(x) f x**2 f(x) cm \\begin{equation}f{\\left(x \\right)} [cm] = x^{2}\\end{equation} Kamodo will print a description of the loaded model when verbose output is on (the default).","title":"instantiation"},{"location":"notebooks/CommandLineInterface/#evaluation","text":"To evaluate a model, provide arguments for each function. kamodo model.params.f[cm]=x**2 model.evaluate.f.x=[-3,-1,1,3] verbose=false f(x=[-3, -1, 1, 3]) cm = [9 1 1 9]","title":"evaluation"},{"location":"notebooks/CommandLineInterface/#visualization","text":"To visualize model output, provide plot parameters similar to evaluation kamodo model.params.f[cm]=x**2 model.plot.f.x.min=-2 model.plot.f.x.max=2 model.plot.f.x.n=25 verbose=False An interactive plot will open with your figure","title":"visualization"},{"location":"notebooks/CommandLineInterface/#kamodofied-models","text":"To work with a kamodofied model, specify the model.class . kamodo model.class=kamodo.readers.tiegcm.TIEGCM_Kamodo model.params.filename=$PWD/s001.nc model.plot.EFLUX.lon=[0]","title":"Kamodofied models"},{"location":"notebooks/CommandLineInterface/#configuration","text":"Kamodo can use configuration files so that arguments do not have to be passed manually. To create your own configuration, create a config.yaml file in your project's directory: config_override : kamodo.yaml gui : external_stylesheets : [] routes_pathname_prefix : /kamodo/ kamodo_output : kamodo_output models : mymodel : class : kamodo.Kamodo evaluate : {} fig_layout : autosize : true params : f : x**2 - 1 y : f**3 plot : f : x : max : 1 min : -1 n : 31 y : x : max : 1 min : -1 n : 31 myothermodel : class : kamodo.Kamodo evaluate : {} fig_layout : autosize : true params : f : x**3 g : y - x mythirdmodel : class : kamodo.test_kamodo.Ktest user_model : class : kamodo.test_kamodo.Ktest plot_conf : animation_opts : null auto_open : true auto_play : true config : null filename : temp-plot.html image : null image_filename : plot_image include_mathjax : cdn include_plotlyjs : cdn link_text : Export to plot.ly output_type : file show_link : false validate : true verbose : true Running kamodo from a directory containing the above config.yaml will produce the same plot as before: ! kamodo mymodel Empty DataFrame Columns: [] Index: [] Empty DataFrame Columns: [] Index: []","title":"Configuration"},{"location":"notebooks/CommandLineInterface/#configuration-priority","text":"Kamodo is built on hydra, which prioritizes configuration using the following rules: If there are two configurations that define the same value, the second one would win. If two configurations are contributing to the same dictionary the result would be the combined dictionary.","title":"Configuration Priority"},{"location":"notebooks/CommandLineInterface/#help","text":"kamodo --help A low-coding command line interface for Kamodo This application allows users to work with kamodo-compatible models and data directly from the command line. Custom models, data, and expressions may be composed by editing config files without needing to write python. == Configuration groups == Compose your configuration from those groups (group=option) == Config == Override anything in the config (foo.bar=value) model: class: kamodo.Kamodo evaluate: {} fig_layout: {} params: {} plot: {} plot_conf: animation_opts: null auto_open: true auto_play: true config: null filename: temp-plot.html image: null image_filename: plot_image include_mathjax: cdn include_plotlyjs: true link_text: Export to plot.ly output_type: file show_link: false validate: true verbose: true Powered by Hydra (https://hydra.cc) Use --hydra-help to view Hydra specific help","title":"Help"},{"location":"notebooks/CommandLineInterface/#tab-completion","text":"Kamodo supports tab completion for bash. To set up bash tab completion, run the following: eval \"$(kamodo -sc install=bash)\"","title":"tab completion"},{"location":"notebooks/FieldIntegration/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Field Integration Techniques \u00b6 Many analysis techniques for vector fields require solving an initial value problem for an arbitrary set of seed points and evaluating such solutions at a chosen resolution. Kamodo makes it easy to generate fieldline solutions by providing a function decorator that wraps scipy's powerful solve_ivp function. Each family of solutions is represented by a single function of a complex parameter. We illustrate the flexibility of this approach in the example below. # initialize from plotly.offline import iplot , plot , init_notebook_mode init_notebook_mode ( connected = True ) from kamodo import Kamodo , event , pointlike , kamodofy , solve import numpy as np import pandas as pd window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} if (typeof require !== 'undefined') { require.undef(\"plotly\"); requirejs.config({ paths: { 'plotly': ['https://cdn.plot.ly/plotly-2.4.2.min'] } }); require(['plotly'], function(Plotly) { window._Plotly = Plotly; }); } Dipole field model \u00b6 We use the following dipole field model that can accept (m,) and (1,m), and (n,m) arrays. def Bdip ( rvec ): \"\"\"Need math to work in a variety of arg shapes\"\"\" muvec = Bdip . muvec r = np . linalg . norm ( rvec , axis = 1 ) r [ r == 0 ] = np . nan try : rhat = rvec / r except : rhat = ( rvec . T / r ) . T try : result = 3 * np . dot ( rhat , muvec . T ) except : result = 3 * np . dot ( rhat . T , muvec . T ) . T result = ( rhat . T * result ) . T try : result = result - muvec except : result = ( result - muvec . T ) . T try : result = result / r ** 3 except : result = ( result . T / r ** 3 ) . T return result # set dipole moment Bdip . muvec = np . array ([ 0 , 0 , - 1 ]) # pointlike enforces dimensionality Bdip = pointlike ( Bdip , '(n,m)->(n,m)' , [ float ], squeeze = 0 ) kamodo = Kamodo () kamodo [ 'Bvec' ] = Bdip # register the dipole field kamodo \\begin{equation}\\vec{B}{\\left(\\vec{r} \\right)} = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} Normalization \u00b6 Instead of solving the initial value problem on the original field, we will be solving on the normalized field. This will mean that the integral path is the same as the arclength, allowing us to control the visual fidelity of the resulting field. Create a normalization function to be applied to our field @kamodofy ( equation = \" \\\\ hat {n} ( \\\\ vec {y} ) = \\\\ vec {y} / \\\\ sqrt{ \\\\ vec {y} \\\\ cdot \\\\ vec {y} }\" ) @pointlike ( signature = '(m,n)->(m,n)' , squeeze = 0 ) def normalized ( yvec ): r = np . linalg . norm ( yvec , axis = 1 ) r [ r == 0 ] = np . nan try : return yvec / r except : return ( yvec . T / r ) . T kamodo [ 'nhat' ] = normalized Create a normalized field kamodo [ 'bhat' ] = \"nhat(Bvec)\" kamodo \\begin{equation}\\vec{B}{\\left(\\vec{r} \\right)} = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} \\begin{equation}\\hat{n}{\\left(\\vec{y} \\right)} = \\hat{n}(\\vec{y}) = \\vec{y}/\\sqrt{\\vec{y} \\cdot \\vec{y}}\\end{equation} \\begin{equation}\\hat{b}{\\left(\\vec{r} \\right)} = \\hat{n}{\\left(\\vec{B}{\\left(\\vec{r} \\right)} \\right)}\\end{equation} Solving the initial value problem \u00b6 Generate a set of seed points for integration x0 = np . linspace ( - np . pi , np . pi , 6 ) y0 = np . linspace ( - np . pi , np . pi , 6 ) z0 = 1 seeds = np . array ( np . column_stack ([ c . ravel () for c in np . meshgrid ( x0 , y0 , z0 )])) Create a stopping boundary for field line integrator @event def boundary ( s , rvec ): r = np . linalg . norm ( rvec ) if np . isnan ( r ): result = 0 else : result = r - 1 return result Solve the initial value problem for the normalized field kamodo [ 'svec' ] = solve ( kamodo . bhat , # the field to be solved seeds , # the initial positions 's' , # the name of the integration parameter ( 0 , 30 ), # the span to integrate over npoints = 60 , # the number of points to evaluate the solution events = boundary , # stop at the boundary ) kamodo \\begin{equation}\\vec{B}{\\left(\\vec{r} \\right)} = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} \\begin{equation}\\hat{n}{\\left(\\vec{y} \\right)} = \\hat{n}(\\vec{y}) = \\vec{y}/\\sqrt{\\vec{y} \\cdot \\vec{y}}\\end{equation} \\begin{equation}\\hat{b}{\\left(\\vec{r} \\right)} = \\hat{n}{\\left(\\vec{B}{\\left(\\vec{r} \\right)} \\right)}\\end{equation} \\begin{equation}\\vec{s}{\\left(s \\right)} = \\lambda{\\left(s \\right)}\\end{equation} The solver returns a family of solutions, represented as a single function of a complex array, \\(\\vec{s}(s)\\) where \\(s\\) is a complex array. Evaluating the Solutions \u00b6 On evaluation, \\(\\vec{s}(s)\\) returns a pandas dataframe. kamodo . svec () . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 seed integral 0.0 -6.610169 -0.347547 -0.347547 -0.924155 -6.101695 -0.615886 -0.615886 -1.261575 -5.593220 -0.922735 -0.922735 -1.525472 -5.084746 -1.256963 -1.256963 -1.713145 -4.576271 -1.608411 -1.608411 -1.822192 When using the default argument above, the solution evaluates at a resolution of npoints/span, stopping at the boundary. Complex parameterization \u00b6 Kamodo represents the family of solutions to the initial value problem as a single function of a complex array. The floor of the real part of the input parameter corresponds to the original seed array: kamodo . svec ([ 0 , 1 , 2 ]) . values array([[-3.14159265, -3.14159265, 1. ], [-1.88495559, -3.14159265, 1. ], [-0.62831853, -3.14159265, 1. ]]) compare with original seeds: seeds [[ 0 , 1 , 2 ]] array([[-3.14159265, -3.14159265, 1. ], [-1.88495559, -3.14159265, 1. ], [-0.62831853, -3.14159265, 1. ]]) The imaginary part denotes the integral along the corresponding solution. Here, we can choose evaluation points that were not in the original solution. Parameters outside the original span will be extrapolated. kamodo . svec ([ - 6 j , - 5 j , 0 , 5 j , 6 j , 4 + 4 j , 4 - 5.777 j ]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 seed integral 0.0 -6.000 -0.674502 -0.674502 -1.320504 -5.000 -1.314574 -1.314574 -1.737228 0.000 -3.141593 -3.141593 1.000000 5.000 -0.120606 -0.120606 0.491892 6.000 0.125472 0.125472 -0.393292 4.0 4.000 0.094223 -0.157038 0.481740 -5.777 0.234804 -0.391340 -0.827054 Plotting Fieldlines \u00b6 We can quickly generate plots for all fieldlines at the default resolution by calling plot with the name of the fieldlines solution. import plotly.io as pio fig = kamodo . plot ( 'svec' ) pio . write_image ( fig , './images/fieldlines.svg' ) To show the direction of the field at each point, we can evaluate \\(\\hat{B}(\\vec{s}(s))\\) fig = kamodo . plot ( 'svec' , bhat = dict ( rvec = kamodo . svec ())) pio . write_image ( fig , './images/fieldlines_vectors.svg' ) Integration totals \u00b6 To compute the total integral for each fieldline individually, we need a function to subtract the integration results at the endpoints. def integral ( fieldline ): endpoints = fieldline . reset_index () . integral . iloc [[ 0 , - 1 ]] return endpoints . values [ - 1 ] - endpoints . values [ 0 ] totals = [] for seed , fieldline in kamodo . svec () . groupby ( level = 'seed' ): totals . append ( integral ( fieldline )) totals [: 5 ] [10.677966101694915, 8.64406779661017, 7.627118644067796, 7.627118644067796, 8.64406779661017] Alternatively, we can use pandas' aggregation methods to apply our function on each fieldline. kamodo . svec () . groupby ( level = 'seed' ) . aggregate ( integral ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 seed 0.0 10.677966 10.677966 10.677966 1.0 8.644068 8.644068 8.644068 2.0 7.627119 7.627119 7.627119 3.0 7.627119 7.627119 7.627119 4.0 8.644068 8.644068 8.644068 5.0 10.677966 10.677966 10.677966 6.0 8.644068 8.644068 8.644068 7.0 6.610169 6.610169 6.610169 8.0 5.084746 5.084746 5.084746 9.0 5.084746 5.084746 5.084746 10.0 6.610169 6.610169 6.610169 11.0 8.644068 8.644068 8.644068 12.0 7.627119 7.627119 7.627119 13.0 5.084746 5.084746 5.084746 14.0 5.593220 5.593220 5.593220 15.0 5.593220 5.593220 5.593220 16.0 5.084746 5.084746 5.084746 17.0 7.627119 7.627119 7.627119 18.0 7.627119 7.627119 7.627119 19.0 5.084746 5.084746 5.084746 20.0 5.593220 5.593220 5.593220 21.0 5.593220 5.593220 5.593220 22.0 5.084746 5.084746 5.084746 23.0 7.627119 7.627119 7.627119 24.0 8.644068 8.644068 8.644068 25.0 6.610169 6.610169 6.610169 26.0 5.084746 5.084746 5.084746 27.0 5.084746 5.084746 5.084746 28.0 6.610169 6.610169 6.610169 29.0 8.644068 8.644068 8.644068 30.0 10.677966 10.677966 10.677966 31.0 8.644068 8.644068 8.644068 32.0 7.627119 7.627119 7.627119 33.0 7.627119 7.627119 7.627119 34.0 8.644068 8.644068 8.644068 35.0 10.677966 10.677966 10.677966","title":"Field Integration"},{"location":"notebooks/FieldIntegration/#field-integration-techniques","text":"Many analysis techniques for vector fields require solving an initial value problem for an arbitrary set of seed points and evaluating such solutions at a chosen resolution. Kamodo makes it easy to generate fieldline solutions by providing a function decorator that wraps scipy's powerful solve_ivp function. Each family of solutions is represented by a single function of a complex parameter. We illustrate the flexibility of this approach in the example below. # initialize from plotly.offline import iplot , plot , init_notebook_mode init_notebook_mode ( connected = True ) from kamodo import Kamodo , event , pointlike , kamodofy , solve import numpy as np import pandas as pd window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} if (typeof require !== 'undefined') { require.undef(\"plotly\"); requirejs.config({ paths: { 'plotly': ['https://cdn.plot.ly/plotly-2.4.2.min'] } }); require(['plotly'], function(Plotly) { window._Plotly = Plotly; }); }","title":"Field Integration Techniques"},{"location":"notebooks/FieldIntegration/#dipole-field-model","text":"We use the following dipole field model that can accept (m,) and (1,m), and (n,m) arrays. def Bdip ( rvec ): \"\"\"Need math to work in a variety of arg shapes\"\"\" muvec = Bdip . muvec r = np . linalg . norm ( rvec , axis = 1 ) r [ r == 0 ] = np . nan try : rhat = rvec / r except : rhat = ( rvec . T / r ) . T try : result = 3 * np . dot ( rhat , muvec . T ) except : result = 3 * np . dot ( rhat . T , muvec . T ) . T result = ( rhat . T * result ) . T try : result = result - muvec except : result = ( result - muvec . T ) . T try : result = result / r ** 3 except : result = ( result . T / r ** 3 ) . T return result # set dipole moment Bdip . muvec = np . array ([ 0 , 0 , - 1 ]) # pointlike enforces dimensionality Bdip = pointlike ( Bdip , '(n,m)->(n,m)' , [ float ], squeeze = 0 ) kamodo = Kamodo () kamodo [ 'Bvec' ] = Bdip # register the dipole field kamodo \\begin{equation}\\vec{B}{\\left(\\vec{r} \\right)} = \\lambda{\\left(\\vec{r} \\right)}\\end{equation}","title":"Dipole field model"},{"location":"notebooks/FieldIntegration/#normalization","text":"Instead of solving the initial value problem on the original field, we will be solving on the normalized field. This will mean that the integral path is the same as the arclength, allowing us to control the visual fidelity of the resulting field. Create a normalization function to be applied to our field @kamodofy ( equation = \" \\\\ hat {n} ( \\\\ vec {y} ) = \\\\ vec {y} / \\\\ sqrt{ \\\\ vec {y} \\\\ cdot \\\\ vec {y} }\" ) @pointlike ( signature = '(m,n)->(m,n)' , squeeze = 0 ) def normalized ( yvec ): r = np . linalg . norm ( yvec , axis = 1 ) r [ r == 0 ] = np . nan try : return yvec / r except : return ( yvec . T / r ) . T kamodo [ 'nhat' ] = normalized Create a normalized field kamodo [ 'bhat' ] = \"nhat(Bvec)\" kamodo \\begin{equation}\\vec{B}{\\left(\\vec{r} \\right)} = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} \\begin{equation}\\hat{n}{\\left(\\vec{y} \\right)} = \\hat{n}(\\vec{y}) = \\vec{y}/\\sqrt{\\vec{y} \\cdot \\vec{y}}\\end{equation} \\begin{equation}\\hat{b}{\\left(\\vec{r} \\right)} = \\hat{n}{\\left(\\vec{B}{\\left(\\vec{r} \\right)} \\right)}\\end{equation}","title":"Normalization"},{"location":"notebooks/FieldIntegration/#solving-the-initial-value-problem","text":"Generate a set of seed points for integration x0 = np . linspace ( - np . pi , np . pi , 6 ) y0 = np . linspace ( - np . pi , np . pi , 6 ) z0 = 1 seeds = np . array ( np . column_stack ([ c . ravel () for c in np . meshgrid ( x0 , y0 , z0 )])) Create a stopping boundary for field line integrator @event def boundary ( s , rvec ): r = np . linalg . norm ( rvec ) if np . isnan ( r ): result = 0 else : result = r - 1 return result Solve the initial value problem for the normalized field kamodo [ 'svec' ] = solve ( kamodo . bhat , # the field to be solved seeds , # the initial positions 's' , # the name of the integration parameter ( 0 , 30 ), # the span to integrate over npoints = 60 , # the number of points to evaluate the solution events = boundary , # stop at the boundary ) kamodo \\begin{equation}\\vec{B}{\\left(\\vec{r} \\right)} = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} \\begin{equation}\\hat{n}{\\left(\\vec{y} \\right)} = \\hat{n}(\\vec{y}) = \\vec{y}/\\sqrt{\\vec{y} \\cdot \\vec{y}}\\end{equation} \\begin{equation}\\hat{b}{\\left(\\vec{r} \\right)} = \\hat{n}{\\left(\\vec{B}{\\left(\\vec{r} \\right)} \\right)}\\end{equation} \\begin{equation}\\vec{s}{\\left(s \\right)} = \\lambda{\\left(s \\right)}\\end{equation} The solver returns a family of solutions, represented as a single function of a complex array, \\(\\vec{s}(s)\\) where \\(s\\) is a complex array.","title":"Solving the initial value problem"},{"location":"notebooks/FieldIntegration/#evaluating-the-solutions","text":"On evaluation, \\(\\vec{s}(s)\\) returns a pandas dataframe. kamodo . svec () . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 seed integral 0.0 -6.610169 -0.347547 -0.347547 -0.924155 -6.101695 -0.615886 -0.615886 -1.261575 -5.593220 -0.922735 -0.922735 -1.525472 -5.084746 -1.256963 -1.256963 -1.713145 -4.576271 -1.608411 -1.608411 -1.822192 When using the default argument above, the solution evaluates at a resolution of npoints/span, stopping at the boundary.","title":"Evaluating the Solutions"},{"location":"notebooks/FieldIntegration/#complex-parameterization","text":"Kamodo represents the family of solutions to the initial value problem as a single function of a complex array. The floor of the real part of the input parameter corresponds to the original seed array: kamodo . svec ([ 0 , 1 , 2 ]) . values array([[-3.14159265, -3.14159265, 1. ], [-1.88495559, -3.14159265, 1. ], [-0.62831853, -3.14159265, 1. ]]) compare with original seeds: seeds [[ 0 , 1 , 2 ]] array([[-3.14159265, -3.14159265, 1. ], [-1.88495559, -3.14159265, 1. ], [-0.62831853, -3.14159265, 1. ]]) The imaginary part denotes the integral along the corresponding solution. Here, we can choose evaluation points that were not in the original solution. Parameters outside the original span will be extrapolated. kamodo . svec ([ - 6 j , - 5 j , 0 , 5 j , 6 j , 4 + 4 j , 4 - 5.777 j ]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 seed integral 0.0 -6.000 -0.674502 -0.674502 -1.320504 -5.000 -1.314574 -1.314574 -1.737228 0.000 -3.141593 -3.141593 1.000000 5.000 -0.120606 -0.120606 0.491892 6.000 0.125472 0.125472 -0.393292 4.0 4.000 0.094223 -0.157038 0.481740 -5.777 0.234804 -0.391340 -0.827054","title":"Complex parameterization"},{"location":"notebooks/FieldIntegration/#plotting-fieldlines","text":"We can quickly generate plots for all fieldlines at the default resolution by calling plot with the name of the fieldlines solution. import plotly.io as pio fig = kamodo . plot ( 'svec' ) pio . write_image ( fig , './images/fieldlines.svg' ) To show the direction of the field at each point, we can evaluate \\(\\hat{B}(\\vec{s}(s))\\) fig = kamodo . plot ( 'svec' , bhat = dict ( rvec = kamodo . svec ())) pio . write_image ( fig , './images/fieldlines_vectors.svg' )","title":"Plotting Fieldlines"},{"location":"notebooks/FieldIntegration/#integration-totals","text":"To compute the total integral for each fieldline individually, we need a function to subtract the integration results at the endpoints. def integral ( fieldline ): endpoints = fieldline . reset_index () . integral . iloc [[ 0 , - 1 ]] return endpoints . values [ - 1 ] - endpoints . values [ 0 ] totals = [] for seed , fieldline in kamodo . svec () . groupby ( level = 'seed' ): totals . append ( integral ( fieldline )) totals [: 5 ] [10.677966101694915, 8.64406779661017, 7.627118644067796, 7.627118644067796, 8.64406779661017] Alternatively, we can use pandas' aggregation methods to apply our function on each fieldline. kamodo . svec () . groupby ( level = 'seed' ) . aggregate ( integral ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 seed 0.0 10.677966 10.677966 10.677966 1.0 8.644068 8.644068 8.644068 2.0 7.627119 7.627119 7.627119 3.0 7.627119 7.627119 7.627119 4.0 8.644068 8.644068 8.644068 5.0 10.677966 10.677966 10.677966 6.0 8.644068 8.644068 8.644068 7.0 6.610169 6.610169 6.610169 8.0 5.084746 5.084746 5.084746 9.0 5.084746 5.084746 5.084746 10.0 6.610169 6.610169 6.610169 11.0 8.644068 8.644068 8.644068 12.0 7.627119 7.627119 7.627119 13.0 5.084746 5.084746 5.084746 14.0 5.593220 5.593220 5.593220 15.0 5.593220 5.593220 5.593220 16.0 5.084746 5.084746 5.084746 17.0 7.627119 7.627119 7.627119 18.0 7.627119 7.627119 7.627119 19.0 5.084746 5.084746 5.084746 20.0 5.593220 5.593220 5.593220 21.0 5.593220 5.593220 5.593220 22.0 5.084746 5.084746 5.084746 23.0 7.627119 7.627119 7.627119 24.0 8.644068 8.644068 8.644068 25.0 6.610169 6.610169 6.610169 26.0 5.084746 5.084746 5.084746 27.0 5.084746 5.084746 5.084746 28.0 6.610169 6.610169 6.610169 29.0 8.644068 8.644068 8.644068 30.0 10.677966 10.677966 10.677966 31.0 8.644068 8.644068 8.644068 32.0 7.627119 7.627119 7.627119 33.0 7.627119 7.627119 7.627119 34.0 8.644068 8.644068 8.644068 35.0 10.677966 10.677966 10.677966","title":"Integration totals"},{"location":"notebooks/Kamodo/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Overview \u00b6 Kamodo provides a functional interface for space weather analysis, visualization, and knowledge discovery, allowing many problems in scientific data analysis to be posed in terms of function composition and evaluation. We'll walk through its general features here. Kamodo objects \u00b6 Users primarily interact with models and data through Kamodo objects. from kamodo import Kamodo Function registration \u00b6 Kamodo objects are essentially python dictionaries storing variable symbols as keys and their interpolating functions as values. New functions may be registered either at the initialization of the Kamodo object or later using dictionary bracket syntax. kamodo = Kamodo ( f = 'x**2' ) kamodo \\begin{equation}f{\\left(x \\right)} = x^{2}\\end{equation} kamodo . f ( 3 ) array(9, dtype=int64) kamodo = Kamodo ( '$x = t^2$' ) kamodo [ 'g' ] = 'y-1' kamodo \\begin{equation}x{\\left(t \\right)} = t^{2}\\end{equation} \\begin{equation}g{\\left(y \\right)} = y - 1\\end{equation} kamodo . g ( 3 ) array(2, dtype=int64) Function composition \u00b6 Kamodo automatically composes functions through specifying on the right-hand-side. kamodo [ 'f' ] = 'g(x)' kamodo \\begin{equation}x{\\left(t \\right)} = t^{2}\\end{equation} \\begin{equation}g{\\left(y \\right)} = y - 1\\end{equation} \\begin{equation}f{\\left(t \\right)} = g{\\left(x{\\left(t \\right)} \\right)}\\end{equation} Here we have defined two functions \\(x(t)\\) , \\(g(y)\\) , and the composition \\(g\u2218f\\) . Kamodo was able to determine that \\(f\\) is implicitly a function of \\(t\\) even though we did not say so in \\(f\\) 's declaration. Function evaluation \u00b6 Kamodo uses sympy's lambdify function to turn the above equations into highly optimized functions for numerical evaluation. We may evaluate \\(f(t)\\) for \\(t=3\\) using \"dot\" notation: kamodo . f ( 3 ) array(8, dtype=int64) help ( kamodo . g ) Help on function _lambdifygenerated in module numexpr: _lambdifygenerated(y) Created with lambdify. Signature: func(y) Expression: y - 1 Source code: def _lambdifygenerated(y): return (evaluate('y - 1', truediv=True)) Imported modules: where the return type is a numpy array. We could also have passed in a numpy array and the result shares the same shape: import numpy as np t = np . linspace ( - 5 , 5 , 100000 ) result = kamodo . f ( t ) assert ( t . shape == result . shape ) Unit conversion \u00b6 Kamodo automatically handles unit conversions. Simply declare units on the left-hand-side of expressions using bracket notation. kamodo = Kamodo ( 'mass[kg] = x' , 'vol[m^3] = y' ) kamodo \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = x\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = y\\end{equation} Unless specified, Kamodo will assign the units for newly defined variables: kamodo [ 'rho' ] = 'mass/vol' kamodo \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = x\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = y\\end{equation} \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{kg}{m^{3}}] = \\frac{\\operatorname{mass}{\\left(x \\right)}}{\\operatorname{vol}{\\left(y \\right)}}\\end{equation} We may override the default behavior by simply naming the our chosen units in the left hand side. kamodo [ 'rho(x,y)[g/cm^3]' ] = 'mass/vol' kamodo \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = x\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = y\\end{equation} \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{g}{cm^{3}}] = \\frac{\\operatorname{mass}{\\left(x \\right)}}{1000 \\operatorname{vol}{\\left(y \\right)}}\\end{equation} Note Kamodo will raise an error if the left and right-hand-side units are incompatible. Even though generated functions are unitless, the units are clearly displayed on the lhs. We think this is a good trade-off between performance and legibility. kamodo . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units mass mass(x) kg mass x {} vol vol(y) m**3 vol y {} rho rho(x, y) g/cm**3 rho(x, y) mass(x)/(1000*vol(y)) {'x': 'cm**(-3)', 'y': 'g'} kamodo . rho ( 3 , 4 ) 0.00075 We can verify that kamodo produces the correct output upon evaluation. assert ( kamodo . rho ( 3 , 8 ) == ( 3 * 1000. ) / ( 8 * 100 ** 3 )) Variable naming conventions \u00b6 Kamodo allows for a wide array of variable names to suite your problem space, including greek, subscripts, superscripts. kamodo = Kamodo ( 'rho = ALPHA+BETA+GAMMA' , 'rvec = t' , 'fprime = x' , 'xvec_i = xvec_iminus1 + 1' , 'F__gravity = G*M*m/R**2' , ) kamodo \\begin{equation}\\rho{\\left(\\alpha,\\beta,\\gamma \\right)} = \\alpha + \\beta + \\gamma\\end{equation} \\begin{equation}\\vec{r}{\\left(t \\right)} = t\\end{equation} \\begin{equation}\\operatorname{{f}'}{\\left(x \\right)} = x\\end{equation} \\begin{equation}\\vec{x}_{i}{\\left(\\vec{x}_{i-1} \\right)} = \\vec{x}_{i-1} + 1\\end{equation} \\begin{equation}\\operatorname{F^{gravity}}{\\left(G,M,R,m \\right)} = \\frac{G M m}{R^{2}}\\end{equation} For more details on variable naming conventions, see the Syntax section. Lambda functions \u00b6 Kamodo borrows heavily from functional programing techniques, including use of the \"lambda\" function , an abstract representation of a function. Think of the lambda as a placeholder when no closed-form expression may be given for a registered function. In the example below, the function rho contains an implementation which may be hidden from the end user. In this case, it simply hands the argument off to another library. def rho ( x ): return np . sin ( x ) When registering the above function as part of a Kamodo object, Kamodo will assign the greek letter \\(\\rho\\) to the left-hand-side following the Syntax Conventions . For the right hand side the generic \\(\\lambda(x)\\) is used to signify that no closed-form expression is available. Kamodo ( rho = rho ) \\begin{equation}\\rho{\\left(x \\right)} = \\lambda{\\left(x \\right)}\\end{equation} If a function author wishes to provide a placeholder expression for the right-hand-side, they may do so using the @kamodofy decorator below. @kamodofy Decorator \u00b6 Many functions can not be written as simple mathematical expressions - they could represent simulation output or observational data. For this reason, we provide a @kamodofy decorator, which turns any callable function into a kamodo-compatible variable and adds metadata that enables unit conversion. from kamodo import kamodofy , Kamodo import numpy as np @kamodofy ( units = 'kg/m**3' , citation = 'Bob et. al, 2018' , equation = 'xy' ) def rho ( x = np . array ([ 3 , 4 , 5 ]), y = np . array ([ 1 , 2 , 3 ])): \"\"\"A function that computes density\"\"\" return x + y kamodo = Kamodo ( rho = rho ) kamodo [ 'den[g/cm^3]' ] = 'rho' kamodo \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{kg}{m^{3}}] = xy\\end{equation} \\begin{equation}\\operatorname{den}{\\left(x,y \\right)}[\\frac{g}{cm^{3}}] = \\frac{\\rho{\\left(x,y \\right)}}{1000}\\end{equation} kamodo . den ( 3 , 4 ) 0.007 kamodo . rho . meta # PyHC standard {'units': 'kg/m**3', 'arg_units': None, 'citation': 'Bob et. al, 2018', 'equation': 'xy', 'hidden_args': []} kamodo . rho () array([4, 6, 8]) kamodo . rho . data # PyHC standard array([4, 6, 8]) Original function doc strings and signatures passed through help ( kamodo . rho ) Help on function rho in module __main__: rho(x=array([3, 4, 5]), y=array([1, 2, 3])) A function that computes density citation: Bob et. al, 2018 kamodo . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units rho rho(x, y) kg/m**3 rho xy None den den(x, y) g/cm**3 den rho(x, y)/1000 {} Visualization \u00b6 Kamodo graphs are generated directly from function signatures by examining the structure of both output and input arguments. from plotting import plot_types plot_types .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } plot_type function out_shape arg_shapes (1,) ((N, M), (N, M), (N, M)) 3d-parametric plotting.surface (N,) ((N,),) 1d-line plotting.line_plot ((N,), (N,)) 2d-line-scalar plotting.line_plot ((N,), (N,), (N,)) 3d-line-scalar plotting.line_plot ((N, 3),) 3d scatter plotting.scatter_plot (N, 2) ((N,),) 2d-line plotting.line_plot ((N, 2),) 2d-vector plotting.vector_plot (N, 3) ((N,),) 3d-line plotting.line_plot ((N, 3),) 3d-vector plotting.vector_plot ((M,), (M,), (M,)) 3d-tri-surface plotting.tri_surface_plot (N, N) ((N,), (N,)) 2d-contour plotting.contour_plot (N, M) ((N,), (M,)) 2d-contour plotting.contour_plot ((M,), (N,)) 2d-contour plotting.contour_plot ((N, M), (N, M)) 2d-contour-skew plotting.contour_plot ((N, M), (N, M), (N, M)) 3d-parametric-scalar plotting.surface ((1,), (N, M), (N, M)) 3d-plane plotting.plane ((N, M), (1,), (N, M)) 3d-plane plotting.plane ((N, M), (N, M), (1,)) 3d-plane plotting.plane (N, 1, M) ((N,), (1,), (M,)) 3d-plane plotting.plane ((1,), (N,), (M,)) 3d-plane plotting.plane (1, N, M) ((N,), (1,), (M,)) 3d-plane plotting.plane (N, M, 1) ((1,), (N,), (M,)) 3d-plane plotting.plane ((N,), (1,), (M,)) 3d-plane plotting.plane ((N,), (M,), (1,)) 3d-plane plotting.plane ((M,), (N,), (1,)) 3d-plane plotting.plane (N, M, 3) ((N,), (M,)) image plotting.image Kamodo uses plotly for visualization, enabling a rich array of interactive graphs and easy web deployment. import plotly.io as pio from plotly.offline import iplot , plot , init_notebook_mode init_notebook_mode ( connected = True ) window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} if (typeof require !== 'undefined') { require.undef(\"plotly\"); requirejs.config({ paths: { 'plotly': ['https://cdn.plot.ly/plotly-2.4.2.min'] } }); require(['plotly'], function(Plotly) { window._Plotly = Plotly; }); } @kamodofy ( units = 'kg/m^3' ) def rho ( x = np . linspace ( 0 , 1 , 20 ), y = np . linspace ( - 1 , 1 , 40 )): \"\"\"A function that computes density\"\"\" x_ , y_ = np . meshgrid ( x , y ) return x_ * y_ kamodo = Kamodo ( rho = rho ) kamodo \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(x,y \\right)}\\end{equation} We will generate an image of this function using plotly fig = kamodo . plot ( 'rho' ) # pio.write_image(fig, 'images/Kamodo_fig1.svg') See the Visualization section for detailed examples. Latex I/O \u00b6 Even though math is the language of physics, most scientific analysis software requires you to learn new programing languages. Kamodo allows users to write their mathematical expressions in LaTeX, a typesetting language most scientists already know: kamodo = Kamodo ( '$rho[kg/m^3] = x^3$' , '$v[cm/s] = y^2$' ) kamodo [ 'p[Pa]' ] = '$ \\\\ rho v^2$' kamodo \\begin{equation}\\rho{\\left(x \\right)}[\\frac{kg}{m^{3}}] = x^{3}\\end{equation} \\begin{equation}v{\\left(y \\right)}[cm / s] = y^{2}\\end{equation} \\begin{equation}p{\\left(x,y \\right)}[Pa] = \\frac{\\rho{\\left(x \\right)} v^{2}{\\left(y \\right)}}{10000}\\end{equation} The resulting equation set may also be exported as a LaTeX string for use in publications: print ( kamodo . to_latex () + ' \\n .' ) \\begin{equation}\\rho{\\left(x \\right)}[\\frac{kg}{m^{3}}] = x^{3}\\end{equation} \\begin{equation}v{\\left(y \\right)}[cm / s] = y^{2}\\end{equation} \\begin{equation}p{\\left(x,y \\right)}[Pa] = \\frac{\\rho{\\left(x \\right)} v^{2}{\\left(y \\right)}}{10000}\\end{equation} . Simulation api \u00b6 Kamodo offers a simple api for functions composed of each other. Define variables as usual (order matters). kamodo = Kamodo () kamodo [ 'y_iplus1' ] = 'x_i + 1' kamodo [ 'x_iplus1' ] = 'y_i - 2' kamodo \\begin{equation}\\operatorname{y_{i+1}}{\\left(x_{i} \\right)} = x_{i} + 1\\end{equation} \\begin{equation}\\operatorname{x_{i+1}}{\\left(y_{i} \\right)} = y_{i} - 2\\end{equation} Now add the update attribute to map functions onto arguments. kamodo . x_iplus1 . update = 'x_i' kamodo . y_iplus1 . update = 'y_i' Create a simulation with initial conditions simulation = kamodo . simulate ( x_i = 0 , steps = 5 ) simulation #an iterator of arg, val dictionaries <generator object simulate at 0x7fb0feac9750> Run the simulation by iterating through the generator. import pandas as pd pd . DataFrame ( simulation ) # pandas conveniently iterates the results for display .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } y_i x_i 0 None 0 1 1 -1 2 0 -2 3 -1 -3 4 -2 -4 5 -3 -5","title":"Introduction"},{"location":"notebooks/Kamodo/#overview","text":"Kamodo provides a functional interface for space weather analysis, visualization, and knowledge discovery, allowing many problems in scientific data analysis to be posed in terms of function composition and evaluation. We'll walk through its general features here.","title":"Overview"},{"location":"notebooks/Kamodo/#kamodo-objects","text":"Users primarily interact with models and data through Kamodo objects. from kamodo import Kamodo","title":"Kamodo objects"},{"location":"notebooks/Kamodo/#function-registration","text":"Kamodo objects are essentially python dictionaries storing variable symbols as keys and their interpolating functions as values. New functions may be registered either at the initialization of the Kamodo object or later using dictionary bracket syntax. kamodo = Kamodo ( f = 'x**2' ) kamodo \\begin{equation}f{\\left(x \\right)} = x^{2}\\end{equation} kamodo . f ( 3 ) array(9, dtype=int64) kamodo = Kamodo ( '$x = t^2$' ) kamodo [ 'g' ] = 'y-1' kamodo \\begin{equation}x{\\left(t \\right)} = t^{2}\\end{equation} \\begin{equation}g{\\left(y \\right)} = y - 1\\end{equation} kamodo . g ( 3 ) array(2, dtype=int64)","title":"Function registration"},{"location":"notebooks/Kamodo/#function-composition","text":"Kamodo automatically composes functions through specifying on the right-hand-side. kamodo [ 'f' ] = 'g(x)' kamodo \\begin{equation}x{\\left(t \\right)} = t^{2}\\end{equation} \\begin{equation}g{\\left(y \\right)} = y - 1\\end{equation} \\begin{equation}f{\\left(t \\right)} = g{\\left(x{\\left(t \\right)} \\right)}\\end{equation} Here we have defined two functions \\(x(t)\\) , \\(g(y)\\) , and the composition \\(g\u2218f\\) . Kamodo was able to determine that \\(f\\) is implicitly a function of \\(t\\) even though we did not say so in \\(f\\) 's declaration.","title":"Function composition"},{"location":"notebooks/Kamodo/#function-evaluation","text":"Kamodo uses sympy's lambdify function to turn the above equations into highly optimized functions for numerical evaluation. We may evaluate \\(f(t)\\) for \\(t=3\\) using \"dot\" notation: kamodo . f ( 3 ) array(8, dtype=int64) help ( kamodo . g ) Help on function _lambdifygenerated in module numexpr: _lambdifygenerated(y) Created with lambdify. Signature: func(y) Expression: y - 1 Source code: def _lambdifygenerated(y): return (evaluate('y - 1', truediv=True)) Imported modules: where the return type is a numpy array. We could also have passed in a numpy array and the result shares the same shape: import numpy as np t = np . linspace ( - 5 , 5 , 100000 ) result = kamodo . f ( t ) assert ( t . shape == result . shape )","title":"Function evaluation"},{"location":"notebooks/Kamodo/#unit-conversion","text":"Kamodo automatically handles unit conversions. Simply declare units on the left-hand-side of expressions using bracket notation. kamodo = Kamodo ( 'mass[kg] = x' , 'vol[m^3] = y' ) kamodo \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = x\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = y\\end{equation} Unless specified, Kamodo will assign the units for newly defined variables: kamodo [ 'rho' ] = 'mass/vol' kamodo \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = x\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = y\\end{equation} \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{kg}{m^{3}}] = \\frac{\\operatorname{mass}{\\left(x \\right)}}{\\operatorname{vol}{\\left(y \\right)}}\\end{equation} We may override the default behavior by simply naming the our chosen units in the left hand side. kamodo [ 'rho(x,y)[g/cm^3]' ] = 'mass/vol' kamodo \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = x\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = y\\end{equation} \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{g}{cm^{3}}] = \\frac{\\operatorname{mass}{\\left(x \\right)}}{1000 \\operatorname{vol}{\\left(y \\right)}}\\end{equation} Note Kamodo will raise an error if the left and right-hand-side units are incompatible. Even though generated functions are unitless, the units are clearly displayed on the lhs. We think this is a good trade-off between performance and legibility. kamodo . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units mass mass(x) kg mass x {} vol vol(y) m**3 vol y {} rho rho(x, y) g/cm**3 rho(x, y) mass(x)/(1000*vol(y)) {'x': 'cm**(-3)', 'y': 'g'} kamodo . rho ( 3 , 4 ) 0.00075 We can verify that kamodo produces the correct output upon evaluation. assert ( kamodo . rho ( 3 , 8 ) == ( 3 * 1000. ) / ( 8 * 100 ** 3 ))","title":"Unit conversion"},{"location":"notebooks/Kamodo/#variable-naming-conventions","text":"Kamodo allows for a wide array of variable names to suite your problem space, including greek, subscripts, superscripts. kamodo = Kamodo ( 'rho = ALPHA+BETA+GAMMA' , 'rvec = t' , 'fprime = x' , 'xvec_i = xvec_iminus1 + 1' , 'F__gravity = G*M*m/R**2' , ) kamodo \\begin{equation}\\rho{\\left(\\alpha,\\beta,\\gamma \\right)} = \\alpha + \\beta + \\gamma\\end{equation} \\begin{equation}\\vec{r}{\\left(t \\right)} = t\\end{equation} \\begin{equation}\\operatorname{{f}'}{\\left(x \\right)} = x\\end{equation} \\begin{equation}\\vec{x}_{i}{\\left(\\vec{x}_{i-1} \\right)} = \\vec{x}_{i-1} + 1\\end{equation} \\begin{equation}\\operatorname{F^{gravity}}{\\left(G,M,R,m \\right)} = \\frac{G M m}{R^{2}}\\end{equation} For more details on variable naming conventions, see the Syntax section.","title":"Variable naming conventions"},{"location":"notebooks/Kamodo/#lambda-functions","text":"Kamodo borrows heavily from functional programing techniques, including use of the \"lambda\" function , an abstract representation of a function. Think of the lambda as a placeholder when no closed-form expression may be given for a registered function. In the example below, the function rho contains an implementation which may be hidden from the end user. In this case, it simply hands the argument off to another library. def rho ( x ): return np . sin ( x ) When registering the above function as part of a Kamodo object, Kamodo will assign the greek letter \\(\\rho\\) to the left-hand-side following the Syntax Conventions . For the right hand side the generic \\(\\lambda(x)\\) is used to signify that no closed-form expression is available. Kamodo ( rho = rho ) \\begin{equation}\\rho{\\left(x \\right)} = \\lambda{\\left(x \\right)}\\end{equation} If a function author wishes to provide a placeholder expression for the right-hand-side, they may do so using the @kamodofy decorator below.","title":"Lambda functions"},{"location":"notebooks/Kamodo/#kamodofy-decorator","text":"Many functions can not be written as simple mathematical expressions - they could represent simulation output or observational data. For this reason, we provide a @kamodofy decorator, which turns any callable function into a kamodo-compatible variable and adds metadata that enables unit conversion. from kamodo import kamodofy , Kamodo import numpy as np @kamodofy ( units = 'kg/m**3' , citation = 'Bob et. al, 2018' , equation = 'xy' ) def rho ( x = np . array ([ 3 , 4 , 5 ]), y = np . array ([ 1 , 2 , 3 ])): \"\"\"A function that computes density\"\"\" return x + y kamodo = Kamodo ( rho = rho ) kamodo [ 'den[g/cm^3]' ] = 'rho' kamodo \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{kg}{m^{3}}] = xy\\end{equation} \\begin{equation}\\operatorname{den}{\\left(x,y \\right)}[\\frac{g}{cm^{3}}] = \\frac{\\rho{\\left(x,y \\right)}}{1000}\\end{equation} kamodo . den ( 3 , 4 ) 0.007 kamodo . rho . meta # PyHC standard {'units': 'kg/m**3', 'arg_units': None, 'citation': 'Bob et. al, 2018', 'equation': 'xy', 'hidden_args': []} kamodo . rho () array([4, 6, 8]) kamodo . rho . data # PyHC standard array([4, 6, 8]) Original function doc strings and signatures passed through help ( kamodo . rho ) Help on function rho in module __main__: rho(x=array([3, 4, 5]), y=array([1, 2, 3])) A function that computes density citation: Bob et. al, 2018 kamodo . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units rho rho(x, y) kg/m**3 rho xy None den den(x, y) g/cm**3 den rho(x, y)/1000 {}","title":"@kamodofy Decorator"},{"location":"notebooks/Kamodo/#visualization","text":"Kamodo graphs are generated directly from function signatures by examining the structure of both output and input arguments. from plotting import plot_types plot_types .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } plot_type function out_shape arg_shapes (1,) ((N, M), (N, M), (N, M)) 3d-parametric plotting.surface (N,) ((N,),) 1d-line plotting.line_plot ((N,), (N,)) 2d-line-scalar plotting.line_plot ((N,), (N,), (N,)) 3d-line-scalar plotting.line_plot ((N, 3),) 3d scatter plotting.scatter_plot (N, 2) ((N,),) 2d-line plotting.line_plot ((N, 2),) 2d-vector plotting.vector_plot (N, 3) ((N,),) 3d-line plotting.line_plot ((N, 3),) 3d-vector plotting.vector_plot ((M,), (M,), (M,)) 3d-tri-surface plotting.tri_surface_plot (N, N) ((N,), (N,)) 2d-contour plotting.contour_plot (N, M) ((N,), (M,)) 2d-contour plotting.contour_plot ((M,), (N,)) 2d-contour plotting.contour_plot ((N, M), (N, M)) 2d-contour-skew plotting.contour_plot ((N, M), (N, M), (N, M)) 3d-parametric-scalar plotting.surface ((1,), (N, M), (N, M)) 3d-plane plotting.plane ((N, M), (1,), (N, M)) 3d-plane plotting.plane ((N, M), (N, M), (1,)) 3d-plane plotting.plane (N, 1, M) ((N,), (1,), (M,)) 3d-plane plotting.plane ((1,), (N,), (M,)) 3d-plane plotting.plane (1, N, M) ((N,), (1,), (M,)) 3d-plane plotting.plane (N, M, 1) ((1,), (N,), (M,)) 3d-plane plotting.plane ((N,), (1,), (M,)) 3d-plane plotting.plane ((N,), (M,), (1,)) 3d-plane plotting.plane ((M,), (N,), (1,)) 3d-plane plotting.plane (N, M, 3) ((N,), (M,)) image plotting.image Kamodo uses plotly for visualization, enabling a rich array of interactive graphs and easy web deployment. import plotly.io as pio from plotly.offline import iplot , plot , init_notebook_mode init_notebook_mode ( connected = True ) window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} if (typeof require !== 'undefined') { require.undef(\"plotly\"); requirejs.config({ paths: { 'plotly': ['https://cdn.plot.ly/plotly-2.4.2.min'] } }); require(['plotly'], function(Plotly) { window._Plotly = Plotly; }); } @kamodofy ( units = 'kg/m^3' ) def rho ( x = np . linspace ( 0 , 1 , 20 ), y = np . linspace ( - 1 , 1 , 40 )): \"\"\"A function that computes density\"\"\" x_ , y_ = np . meshgrid ( x , y ) return x_ * y_ kamodo = Kamodo ( rho = rho ) kamodo \\begin{equation}\\rho{\\left(x,y \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(x,y \\right)}\\end{equation} We will generate an image of this function using plotly fig = kamodo . plot ( 'rho' ) # pio.write_image(fig, 'images/Kamodo_fig1.svg') See the Visualization section for detailed examples.","title":"Visualization"},{"location":"notebooks/Kamodo/#latex-io","text":"Even though math is the language of physics, most scientific analysis software requires you to learn new programing languages. Kamodo allows users to write their mathematical expressions in LaTeX, a typesetting language most scientists already know: kamodo = Kamodo ( '$rho[kg/m^3] = x^3$' , '$v[cm/s] = y^2$' ) kamodo [ 'p[Pa]' ] = '$ \\\\ rho v^2$' kamodo \\begin{equation}\\rho{\\left(x \\right)}[\\frac{kg}{m^{3}}] = x^{3}\\end{equation} \\begin{equation}v{\\left(y \\right)}[cm / s] = y^{2}\\end{equation} \\begin{equation}p{\\left(x,y \\right)}[Pa] = \\frac{\\rho{\\left(x \\right)} v^{2}{\\left(y \\right)}}{10000}\\end{equation} The resulting equation set may also be exported as a LaTeX string for use in publications: print ( kamodo . to_latex () + ' \\n .' ) \\begin{equation}\\rho{\\left(x \\right)}[\\frac{kg}{m^{3}}] = x^{3}\\end{equation} \\begin{equation}v{\\left(y \\right)}[cm / s] = y^{2}\\end{equation} \\begin{equation}p{\\left(x,y \\right)}[Pa] = \\frac{\\rho{\\left(x \\right)} v^{2}{\\left(y \\right)}}{10000}\\end{equation} .","title":"Latex I/O"},{"location":"notebooks/Kamodo/#simulation-api","text":"Kamodo offers a simple api for functions composed of each other. Define variables as usual (order matters). kamodo = Kamodo () kamodo [ 'y_iplus1' ] = 'x_i + 1' kamodo [ 'x_iplus1' ] = 'y_i - 2' kamodo \\begin{equation}\\operatorname{y_{i+1}}{\\left(x_{i} \\right)} = x_{i} + 1\\end{equation} \\begin{equation}\\operatorname{x_{i+1}}{\\left(y_{i} \\right)} = y_{i} - 2\\end{equation} Now add the update attribute to map functions onto arguments. kamodo . x_iplus1 . update = 'x_i' kamodo . y_iplus1 . update = 'y_i' Create a simulation with initial conditions simulation = kamodo . simulate ( x_i = 0 , steps = 5 ) simulation #an iterator of arg, val dictionaries <generator object simulate at 0x7fb0feac9750> Run the simulation by iterating through the generator. import pandas as pd pd . DataFrame ( simulation ) # pandas conveniently iterates the results for display .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } y_i x_i 0 None 0 1 1 -1 2 0 -2 3 -1 -3 4 -2 -4 5 -3 -5","title":"Simulation api"},{"location":"notebooks/Kamodofying_Models/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Kamodofication Tutorial \u00b6 This tutorial focuses on building a Kamodofied model from scratch. To see the full implementation, skip down to the Final-Implementation . Kamodofication requirements \u00b6 To Kamodofy models and data representing physical quantities, we need to define a set of functions representing the interpolation of each physical variable having the following properties: A function name and arguments that follows kamodo's Syntax conventions Default arrays for input arguments A meta attribute containing: 'units' - physical units of the values returned by the function 'citation' - How the model or data source should be cited 'equation' - LaTeX representation of this model/data source (if available) 'hidden_args' - A list of function arguments that should not be rendered A data attribute - The array holding the variable (if available) Any docstrings that provide further context Model Reader Tutorial \u00b6 Model Readers load data from disk (or server) and provide methods for interpolation. We require that for each variable of interest, the model reader should provide at least one interpolation method that satisfies all of the above requirements. Each model reader will: Open/close files Manage state variables Initialize interpolators Kamodofy interpolators Register functions Minimal Example: one variable \u00b6 from kamodo import Kamodo , kamodofy , gridify from scipy.interpolate import RegularGridInterpolator import numpy as np import plotly.io as pio class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg*m**-3' ) def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model opening myfile.dat \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} we can call the registered function with multiple values, getting nan if out of bounds: model . rho ([[ 2 , 5 , 8 ], [ 0 , 0 , 0 ]]) array([83.244, nan]) However, the registered function has no default parameters, so an error will be raised if we do not provide an argument. try : model . rho () except TypeError as m : print ( m ) interpolator() missing 1 required positional argument: 'xvec' At this point, the end-user of the model cannot generate quick-look graphics: try : model . plot ( 'rho' ) except TypeError as m : print ( m ) interpolator() missing 1 required positional argument: 'xvec'[] In order to generate any plots, the user must already know where they can place resolution. For example, they could inspect some of the attributes of the model and guess the size of the domain, then choose points from that space. xx , yy , zz = np . meshgrid ( model . x , model . y , model . z ) points = np . column_stack ([ xx . ravel (), yy . ravel (), zz . ravel ()]) randints = np . random . randint ( 0 , len ( points ), 1000 ) fig = model . plot ( rho = dict ( xvec = points [ randints ] )) # pio.write_image(fig, 'images/kamodofied1.svg') Hopefully, the user doesn't choose points where the solution may be invalid. Next, we'll modify the original function to provide a griddable variable with default parameters. Including defaults \u00b6 The above example produced a kamodofied model with one variable, but we are unable to produce quick-look graphics, which required the user to inspect the model to guess where interpolation may be valid. Here we show how to include defaults so the user doesn't have to guess. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg/m**3' ) @gridify ( x = self . x , y = self . y , z = self . z ) # <--- The only change to the model def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model opening myfile.dat \\begin{equation}\\rho{\\left(x,y,z \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(x,y,z \\right)}\\end{equation} By adding the @gridify line, we have modified the original function to be one that generates gridded data. Moreover, the variable now has default parameters. model . rho () . shape (22, 11, 33) We can now specify one or more arguments to get a plane mapping of the solution. model . rho ( z = 8 ) . shape (22, 11) But how do we know to choose the plane z=8 for a valid solution? We can use kamodo's function inspection to get the default ranges for each parameter. from kamodo import get_defaults get_defaults ( model . rho )[ 'z' ] . mean () 8.0 Final Implementation \u00b6 In the final implementation of our model reader, we include multiple variables with different function signatures. Here, the gridded solutions have suffixes _ijk to emphasize their structure. This allows more flexibility for the end user. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz pressure_data = xx ** 2 + yy ** 2 + zz ** 2 self . variables = dict ( rho = dict ( units = 'kg/m**3' , data = density_data ), P = dict ( units = 'nPa' , data = pressure_data )) # Prepare model for function registration super ( MyModel , self ) . __init__ ( ** kwargs ) for varname in self . variables : units = self . variables [ varname ][ 'units' ] self . register_variable ( varname , units ) def register_variable ( self , varname , units ): interpolator = self . get_grid_interpolator ( varname ) # store the interpolator self . variables [ varname ][ 'interpolator' ] = interpolator def interpolate ( xvec ): return self . variables [ varname ][ 'interpolator' ]( xvec ) # update docstring for this variable interpolate . __doc__ = \"A function that returns {} in [ {} ].\" . format ( varname , units ) self [ varname ] = kamodofy ( interpolate , units = units , citation = \"Pembroke et al 2019\" , data = None ) self [ varname + '_ijk' ] = kamodofy ( gridify ( self [ varname ], x_i = self . x , y_j = self . y , z_k = self . z , squeeze = False ), units = units , citation = \"Pembroke et al 2019\" , data = self . variables [ varname ][ 'data' ]) def get_grid_interpolator ( self , varname ): \"\"\"create a regulard grid interpolator for this variable\"\"\" data = self . variables [ varname ][ 'data' ] interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), data , bounds_error = False , fill_value = self . missing_value ) return interpolator model = MyModel ( 'myfile.dat' ) model opening myfile.dat \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\rho_{ijk}{\\left(x_{i},y_{j},z_{k} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(x_{i},y_{j},z_{k} \\right)}\\end{equation} \\begin{equation}P{\\left(\\vec{x} \\right)}[nPa] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\operatorname{P_{ijk}}{\\left(x_{i},y_{j},z_{k} \\right)}[nPa] = \\lambda{\\left(x_{i},y_{j},z_{k} \\right)}\\end{equation} model . rho (( 2 , 5 , 8 )) array(83.244) model . P (( 2 , 5 , 8 )) array(93.02) model . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units rho rho(xvec) kg/m**3 rho None None rho_ijk rho_ijk(x_i, y_j, z_k) kg/m**3 rho_ijk None None P P(xvec) nPa P None None P_ijk P_ijk(x_i, y_j, z_k) nPa P_ijk None None Here the @kamodofy decorator handles the provisioning of kamodo-specific metadata. For example, the declared function rho now has a meta attribute: model . rho . meta {'units': 'kg/m**3', 'arg_units': None, 'citation': 'Pembroke et al 2019', 'equation': None, 'hidden_args': []} @kamodofy also adds the data attribute, by calling the function with its default parameters: model . rho_ijk . data . shape (11, 22, 33) Combined models \u00b6 We could also register the model's interpolating method as part of some other Kamodo object, such as another kamodofied model reader or data source: from kamodo import Kamodo kamodo = Kamodo ( rho = model . rho ) kamodo \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} We can now compose our density function with expressions defined by other models: kamodo [ 'vol[m^3]' ] = '4/3 * pi * (xvec)**(3/2)' kamodo \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(\\vec{x} \\right)}[m^{3}] = \\frac{4 \\pi \\vec{x}^{\\frac{3}{2}}}{3}\\end{equation} kamodo [ 'mass' ] = 'rho*vol' kamodo \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(\\vec{x} \\right)}[m^{3}] = \\frac{4 \\pi \\vec{x}^{\\frac{3}{2}}}{3}\\end{equation} \\begin{equation}\\operatorname{mass}{\\left(\\vec{x} \\right)}[kg] = \\rho{\\left(\\vec{x} \\right)} \\operatorname{vol}{\\left(\\vec{x} \\right)}\\end{equation} kamodo . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units rho rho(xvec) kg/m**3 rho None None vol vol(xvec) m**3 vol 4*pi*xvec**(3/2)/3 {} mass mass(xvec) kg mass rho(xvec)*vol(xvec) {} The following lines will save the image to your working directory. Note Saving images requires plotly-orca-1.2.1 , available through conda: conda install -c plotly plotly-orca model . rho_ijk () . shape (22, 11, 33) import plotly.io as pio fig = model . plot ( rho_ijk = dict ( z_k = model . z . mean ())) from plotly.offline import iplot , init_notebook_mode , plot init_notebook_mode ( connected = True ) window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} if (typeof require !== 'undefined') { require.undef(\"plotly\"); requirejs.config({ paths: { 'plotly': ['https://cdn.plot.ly/plotly-2.4.2.min'] } }); require(['plotly'], function(Plotly) { window._Plotly = Plotly; }); } fig = model . plot ( rho_ijk = dict ( z_k = [ model . z . mean ()])) pio . write_image ( fig , 'kamodofied_model_1.svg' , validate = False ) We use markdown to embed the image into the notebook. Alternative ways to graph: ## uncomment to open interactive plot in the notebook # from plotly.offline import init_notebook_mode, iplot # init_notebook_mode(connected = True) # iplot(kamodo.plot(rho = dict(x = model.x.mean()))) # # uncomment to open interactive plot in separate tab # from plotly.offline import plot # plot(kamodo.plot(rho = dict(z = 8)))","title":"Kamodofying Models"},{"location":"notebooks/Kamodofying_Models/#kamodofication-tutorial","text":"This tutorial focuses on building a Kamodofied model from scratch. To see the full implementation, skip down to the Final-Implementation .","title":"Kamodofication Tutorial"},{"location":"notebooks/Kamodofying_Models/#kamodofication-requirements","text":"To Kamodofy models and data representing physical quantities, we need to define a set of functions representing the interpolation of each physical variable having the following properties: A function name and arguments that follows kamodo's Syntax conventions Default arrays for input arguments A meta attribute containing: 'units' - physical units of the values returned by the function 'citation' - How the model or data source should be cited 'equation' - LaTeX representation of this model/data source (if available) 'hidden_args' - A list of function arguments that should not be rendered A data attribute - The array holding the variable (if available) Any docstrings that provide further context","title":"Kamodofication requirements"},{"location":"notebooks/Kamodofying_Models/#model-reader-tutorial","text":"Model Readers load data from disk (or server) and provide methods for interpolation. We require that for each variable of interest, the model reader should provide at least one interpolation method that satisfies all of the above requirements. Each model reader will: Open/close files Manage state variables Initialize interpolators Kamodofy interpolators Register functions","title":"Model Reader Tutorial"},{"location":"notebooks/Kamodofying_Models/#minimal-example-one-variable","text":"from kamodo import Kamodo , kamodofy , gridify from scipy.interpolate import RegularGridInterpolator import numpy as np import plotly.io as pio class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg*m**-3' ) def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model opening myfile.dat \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} we can call the registered function with multiple values, getting nan if out of bounds: model . rho ([[ 2 , 5 , 8 ], [ 0 , 0 , 0 ]]) array([83.244, nan]) However, the registered function has no default parameters, so an error will be raised if we do not provide an argument. try : model . rho () except TypeError as m : print ( m ) interpolator() missing 1 required positional argument: 'xvec' At this point, the end-user of the model cannot generate quick-look graphics: try : model . plot ( 'rho' ) except TypeError as m : print ( m ) interpolator() missing 1 required positional argument: 'xvec'[] In order to generate any plots, the user must already know where they can place resolution. For example, they could inspect some of the attributes of the model and guess the size of the domain, then choose points from that space. xx , yy , zz = np . meshgrid ( model . x , model . y , model . z ) points = np . column_stack ([ xx . ravel (), yy . ravel (), zz . ravel ()]) randints = np . random . randint ( 0 , len ( points ), 1000 ) fig = model . plot ( rho = dict ( xvec = points [ randints ] )) # pio.write_image(fig, 'images/kamodofied1.svg') Hopefully, the user doesn't choose points where the solution may be invalid. Next, we'll modify the original function to provide a griddable variable with default parameters.","title":"Minimal Example: one variable"},{"location":"notebooks/Kamodofying_Models/#including-defaults","text":"The above example produced a kamodofied model with one variable, but we are unable to produce quick-look graphics, which required the user to inspect the model to guess where interpolation may be valid. Here we show how to include defaults so the user doesn't have to guess. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg/m**3' ) @gridify ( x = self . x , y = self . y , z = self . z ) # <--- The only change to the model def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model opening myfile.dat \\begin{equation}\\rho{\\left(x,y,z \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(x,y,z \\right)}\\end{equation} By adding the @gridify line, we have modified the original function to be one that generates gridded data. Moreover, the variable now has default parameters. model . rho () . shape (22, 11, 33) We can now specify one or more arguments to get a plane mapping of the solution. model . rho ( z = 8 ) . shape (22, 11) But how do we know to choose the plane z=8 for a valid solution? We can use kamodo's function inspection to get the default ranges for each parameter. from kamodo import get_defaults get_defaults ( model . rho )[ 'z' ] . mean () 8.0","title":"Including defaults"},{"location":"notebooks/Kamodofying_Models/#final-implementation","text":"In the final implementation of our model reader, we include multiple variables with different function signatures. Here, the gridded solutions have suffixes _ijk to emphasize their structure. This allows more flexibility for the end user. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz pressure_data = xx ** 2 + yy ** 2 + zz ** 2 self . variables = dict ( rho = dict ( units = 'kg/m**3' , data = density_data ), P = dict ( units = 'nPa' , data = pressure_data )) # Prepare model for function registration super ( MyModel , self ) . __init__ ( ** kwargs ) for varname in self . variables : units = self . variables [ varname ][ 'units' ] self . register_variable ( varname , units ) def register_variable ( self , varname , units ): interpolator = self . get_grid_interpolator ( varname ) # store the interpolator self . variables [ varname ][ 'interpolator' ] = interpolator def interpolate ( xvec ): return self . variables [ varname ][ 'interpolator' ]( xvec ) # update docstring for this variable interpolate . __doc__ = \"A function that returns {} in [ {} ].\" . format ( varname , units ) self [ varname ] = kamodofy ( interpolate , units = units , citation = \"Pembroke et al 2019\" , data = None ) self [ varname + '_ijk' ] = kamodofy ( gridify ( self [ varname ], x_i = self . x , y_j = self . y , z_k = self . z , squeeze = False ), units = units , citation = \"Pembroke et al 2019\" , data = self . variables [ varname ][ 'data' ]) def get_grid_interpolator ( self , varname ): \"\"\"create a regulard grid interpolator for this variable\"\"\" data = self . variables [ varname ][ 'data' ] interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), data , bounds_error = False , fill_value = self . missing_value ) return interpolator model = MyModel ( 'myfile.dat' ) model opening myfile.dat \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\rho_{ijk}{\\left(x_{i},y_{j},z_{k} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(x_{i},y_{j},z_{k} \\right)}\\end{equation} \\begin{equation}P{\\left(\\vec{x} \\right)}[nPa] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\operatorname{P_{ijk}}{\\left(x_{i},y_{j},z_{k} \\right)}[nPa] = \\lambda{\\left(x_{i},y_{j},z_{k} \\right)}\\end{equation} model . rho (( 2 , 5 , 8 )) array(83.244) model . P (( 2 , 5 , 8 )) array(93.02) model . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units rho rho(xvec) kg/m**3 rho None None rho_ijk rho_ijk(x_i, y_j, z_k) kg/m**3 rho_ijk None None P P(xvec) nPa P None None P_ijk P_ijk(x_i, y_j, z_k) nPa P_ijk None None Here the @kamodofy decorator handles the provisioning of kamodo-specific metadata. For example, the declared function rho now has a meta attribute: model . rho . meta {'units': 'kg/m**3', 'arg_units': None, 'citation': 'Pembroke et al 2019', 'equation': None, 'hidden_args': []} @kamodofy also adds the data attribute, by calling the function with its default parameters: model . rho_ijk . data . shape (11, 22, 33)","title":"Final Implementation"},{"location":"notebooks/Kamodofying_Models/#combined-models","text":"We could also register the model's interpolating method as part of some other Kamodo object, such as another kamodofied model reader or data source: from kamodo import Kamodo kamodo = Kamodo ( rho = model . rho ) kamodo \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} We can now compose our density function with expressions defined by other models: kamodo [ 'vol[m^3]' ] = '4/3 * pi * (xvec)**(3/2)' kamodo \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(\\vec{x} \\right)}[m^{3}] = \\frac{4 \\pi \\vec{x}^{\\frac{3}{2}}}{3}\\end{equation} kamodo [ 'mass' ] = 'rho*vol' kamodo \\begin{equation}\\rho{\\left(\\vec{x} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(\\vec{x} \\right)}\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(\\vec{x} \\right)}[m^{3}] = \\frac{4 \\pi \\vec{x}^{\\frac{3}{2}}}{3}\\end{equation} \\begin{equation}\\operatorname{mass}{\\left(\\vec{x} \\right)}[kg] = \\rho{\\left(\\vec{x} \\right)} \\operatorname{vol}{\\left(\\vec{x} \\right)}\\end{equation} kamodo . detail () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } symbol units lhs rhs arg_units rho rho(xvec) kg/m**3 rho None None vol vol(xvec) m**3 vol 4*pi*xvec**(3/2)/3 {} mass mass(xvec) kg mass rho(xvec)*vol(xvec) {} The following lines will save the image to your working directory. Note Saving images requires plotly-orca-1.2.1 , available through conda: conda install -c plotly plotly-orca model . rho_ijk () . shape (22, 11, 33) import plotly.io as pio fig = model . plot ( rho_ijk = dict ( z_k = model . z . mean ())) from plotly.offline import iplot , init_notebook_mode , plot init_notebook_mode ( connected = True ) window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} if (typeof require !== 'undefined') { require.undef(\"plotly\"); requirejs.config({ paths: { 'plotly': ['https://cdn.plot.ly/plotly-2.4.2.min'] } }); require(['plotly'], function(Plotly) { window._Plotly = Plotly; }); } fig = model . plot ( rho_ijk = dict ( z_k = [ model . z . mean ()])) pio . write_image ( fig , 'kamodofied_model_1.svg' , validate = False ) We use markdown to embed the image into the notebook. Alternative ways to graph: ## uncomment to open interactive plot in the notebook # from plotly.offline import init_notebook_mode, iplot # init_notebook_mode(connected = True) # iplot(kamodo.plot(rho = dict(x = model.x.mean()))) # # uncomment to open interactive plot in separate tab # from plotly.offline import plot # plot(kamodo.plot(rho = dict(z = 8)))","title":"Combined models"},{"location":"notebooks/Syntax/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); from kamodo.kamodo import Kamodo LaTeX support \u00b6 Kamodo supports both python and LaTex-formatted expressions as input. For LaTeX, you must wrap your expression in $ $ : Kamodo ( f = 'x**2 + y**2' , g = '$2x^2 + 3y^2$' ) \\begin{equation}f{\\left(x,y \\right)} = x^{2} + y^{2}\\end{equation} \\begin{equation}g{\\left(x,y \\right)} = 2 x^{2} + 3 y^{2}\\end{equation} Conventions \u00b6 Kamodo's variable names have to follow python's naming conventions - only numbers, letters, and underscores, which are too restrictive for mathematical symbols. Therefore, Kamodo uses sympy's conventions when generating LaTeX from variable names, which provide a means to write mathematical symbols in a way ammenable to python. More details of sympy's parsing may be found here . Kamodo also adds some additional features not covered by sympy. Superscripts/Subscripts \u00b6 Subscripts are encoded with single underscores. Superscripts are encoded with double underscores. Combinations are possible. Kamodo ( 'x_i = a' , 'y__j = b' , 'z_oxygen__2 = c' ) \\begin{equation}\\operatorname{x_{i}}{\\left(a \\right)} = a\\end{equation} \\begin{equation}\\operatorname{y^{j}}{\\left(b \\right)} = b\\end{equation} \\begin{equation}\\operatorname{z^{2}_{oxygen}}{\\left(c \\right)} = c\\end{equation} Greek letters \u00b6 Most greek letters are supported using their corresponding english name. Use capitalization if the greek letter should also be capitalized. Kamodo ( rho = 'ALPHA+BETA+Gamma' ) \\begin{equation}\\rho{\\left(\\alpha,\\beta,\\Gamma \\right)} = \\alpha + \\beta + \\Gamma\\end{equation} Warning Some greek letters (e.g. pi, zeta) may conflict with Sympy's namespace. In that case, use all caps (e.g. PI, ZETA) plus/minus operators \u00b6 In Python we cannot have variables embedded with + or - , but we may still need these symbols to represent, say ionization or simulation time step. The table below shows how we map from (part of) a variable name to its corresponding latex output. variable to latex plus + minus - comma , LEFT \\\\left ( RIGHT \\\\right ) prime ' Here is how you would use these in your functions: Kamodo ( x_iplus1 = 'x_i*.9' , O__minus = 'e**-h' , OLEFT3PRIGHT = 't' , fprime = 'x' ) \\begin{equation}\\operatorname{x_{i+1}}{\\left(x_{i} \\right)} = 0.9 x_{i}\\end{equation} \\begin{equation}\\operatorname{O^{-}}{\\left(e,h \\right)} = e^{- h}\\end{equation} \\begin{equation}\\operatorname{O\\left (3P\\right )}{\\left(t \\right)} = t\\end{equation} \\begin{equation}\\operatorname{{f}'}{\\left(x \\right)} = x\\end{equation} Bold font \u00b6 Use the bm suffix to make a variable bold face Kamodo ( Gbm = 'x' , g = 'y' ) \\begin{equation}\\boldsymbol{G}{\\left(x \\right)} = x\\end{equation} \\begin{equation}g{\\left(y \\right)} = y\\end{equation} Vectors \u00b6 Use the vec suffix to place \\(\\vec{}\\) above the preceding symbol. The \\(\\hat{}\\) symbol works similarly. Kamodo ( fvec = '-rvec' , bhat = 'x' ) \\begin{equation}\\vec{f}{\\left(\\vec{r} \\right)} = - \\vec{r}\\end{equation} \\begin{equation}\\hat{b}{\\left(x \\right)} = x\\end{equation} Variable reuse \u00b6 Variables may only have one function representing their evaluation. If you try to define a variable twice, the second version will override the first. However, if you want to represent that variable in a different context but keep using its name, there are two options: Annotation - add superscripts/subscripts to distinguish between the different implentations. Mimicry - use a new name that produces the same LaTeX output. Kamodo ( rho = 'x + y + z' , RHO = 'r*sin(theta)*cos(phi)' , rho_2D = 'x + y' ) \\begin{equation}\\rho{\\left(x,y,z \\right)} = x + y + z\\end{equation} \\begin{equation}\\rho{\\left(\\phi,r,\\theta \\right)} = r \\sin{\\left(\\theta \\right)} \\cos{\\left(\\phi \\right)}\\end{equation} \\begin{equation}\\rho_{2D}{\\left(x,y \\right)} = x + y\\end{equation} Warning Mimicry can cause confusion if the signature of the left-hand-side does not change, as in the example below: Kamodo ( rho = 'x + y' , RHO = '3*x + y' ) \\begin{equation}\\rho{\\left(x,y \\right)} = x + y\\end{equation} \\begin{equation}\\rho{\\left(x,y \\right)} = 3 x + y\\end{equation}","title":"Syntax"},{"location":"notebooks/Syntax/#latex-support","text":"Kamodo supports both python and LaTex-formatted expressions as input. For LaTeX, you must wrap your expression in $ $ : Kamodo ( f = 'x**2 + y**2' , g = '$2x^2 + 3y^2$' ) \\begin{equation}f{\\left(x,y \\right)} = x^{2} + y^{2}\\end{equation} \\begin{equation}g{\\left(x,y \\right)} = 2 x^{2} + 3 y^{2}\\end{equation}","title":"LaTeX support"},{"location":"notebooks/Syntax/#conventions","text":"Kamodo's variable names have to follow python's naming conventions - only numbers, letters, and underscores, which are too restrictive for mathematical symbols. Therefore, Kamodo uses sympy's conventions when generating LaTeX from variable names, which provide a means to write mathematical symbols in a way ammenable to python. More details of sympy's parsing may be found here . Kamodo also adds some additional features not covered by sympy.","title":"Conventions"},{"location":"notebooks/Syntax/#superscriptssubscripts","text":"Subscripts are encoded with single underscores. Superscripts are encoded with double underscores. Combinations are possible. Kamodo ( 'x_i = a' , 'y__j = b' , 'z_oxygen__2 = c' ) \\begin{equation}\\operatorname{x_{i}}{\\left(a \\right)} = a\\end{equation} \\begin{equation}\\operatorname{y^{j}}{\\left(b \\right)} = b\\end{equation} \\begin{equation}\\operatorname{z^{2}_{oxygen}}{\\left(c \\right)} = c\\end{equation}","title":"Superscripts/Subscripts"},{"location":"notebooks/Syntax/#greek-letters","text":"Most greek letters are supported using their corresponding english name. Use capitalization if the greek letter should also be capitalized. Kamodo ( rho = 'ALPHA+BETA+Gamma' ) \\begin{equation}\\rho{\\left(\\alpha,\\beta,\\Gamma \\right)} = \\alpha + \\beta + \\Gamma\\end{equation} Warning Some greek letters (e.g. pi, zeta) may conflict with Sympy's namespace. In that case, use all caps (e.g. PI, ZETA)","title":"Greek letters"},{"location":"notebooks/Syntax/#plusminus-operators","text":"In Python we cannot have variables embedded with + or - , but we may still need these symbols to represent, say ionization or simulation time step. The table below shows how we map from (part of) a variable name to its corresponding latex output. variable to latex plus + minus - comma , LEFT \\\\left ( RIGHT \\\\right ) prime ' Here is how you would use these in your functions: Kamodo ( x_iplus1 = 'x_i*.9' , O__minus = 'e**-h' , OLEFT3PRIGHT = 't' , fprime = 'x' ) \\begin{equation}\\operatorname{x_{i+1}}{\\left(x_{i} \\right)} = 0.9 x_{i}\\end{equation} \\begin{equation}\\operatorname{O^{-}}{\\left(e,h \\right)} = e^{- h}\\end{equation} \\begin{equation}\\operatorname{O\\left (3P\\right )}{\\left(t \\right)} = t\\end{equation} \\begin{equation}\\operatorname{{f}'}{\\left(x \\right)} = x\\end{equation}","title":"plus/minus operators"},{"location":"notebooks/Syntax/#bold-font","text":"Use the bm suffix to make a variable bold face Kamodo ( Gbm = 'x' , g = 'y' ) \\begin{equation}\\boldsymbol{G}{\\left(x \\right)} = x\\end{equation} \\begin{equation}g{\\left(y \\right)} = y\\end{equation}","title":"Bold font"},{"location":"notebooks/Syntax/#vectors","text":"Use the vec suffix to place \\(\\vec{}\\) above the preceding symbol. The \\(\\hat{}\\) symbol works similarly. Kamodo ( fvec = '-rvec' , bhat = 'x' ) \\begin{equation}\\vec{f}{\\left(\\vec{r} \\right)} = - \\vec{r}\\end{equation} \\begin{equation}\\hat{b}{\\left(x \\right)} = x\\end{equation}","title":"Vectors"},{"location":"notebooks/Syntax/#variable-reuse","text":"Variables may only have one function representing their evaluation. If you try to define a variable twice, the second version will override the first. However, if you want to represent that variable in a different context but keep using its name, there are two options: Annotation - add superscripts/subscripts to distinguish between the different implentations. Mimicry - use a new name that produces the same LaTeX output. Kamodo ( rho = 'x + y + z' , RHO = 'r*sin(theta)*cos(phi)' , rho_2D = 'x + y' ) \\begin{equation}\\rho{\\left(x,y,z \\right)} = x + y + z\\end{equation} \\begin{equation}\\rho{\\left(\\phi,r,\\theta \\right)} = r \\sin{\\left(\\theta \\right)} \\cos{\\left(\\phi \\right)}\\end{equation} \\begin{equation}\\rho_{2D}{\\left(x,y \\right)} = x + y\\end{equation} Warning Mimicry can cause confusion if the signature of the left-hand-side does not change, as in the example below: Kamodo ( rho = 'x + y' , RHO = '3*x + y' ) \\begin{equation}\\rho{\\left(x,y \\right)} = x + y\\end{equation} \\begin{equation}\\rho{\\left(x,y \\right)} = 3 x + y\\end{equation}","title":"Variable reuse"},{"location":"notebooks/Visualization/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Visualization \u00b6 Overview \u00b6 Visualization poses a significant challenge for the space weather community: output from models and data are very domain-specific, both in content (coordinate systems, units) and in representation (file formats and data structures). On the other hand, science users also have their preferred context for analyzing these results - for instance, they may only want simulation results interpolated on a satellite trajectory and in a specific coordinate system with their own prefered units. Kamodo aims to strike a balance between the intent of the model (or data) provider and the goals of the user, by making it easy for developers to provide context for their output and for users to easily change that context. It accomplishes this in two ways: By leveraging default arguments given by model and data providers By mapping the shape of function inputs and output to certain registered plot types This strategy allows Kamodo to automatically generate plots for arbitrary model output and data sources, while still allowing for customization by the end user. Available Plot Types \u00b6 Kamodo keeps a registry of plotting functions, indexed by argument shape and output shape. from kamodo.plotting import plot_types plot_types .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } plot_type function out_shape arg_shapes (1,) ((N, M), (N, M), (N, M)) 3d-parametric kamodo.plotting.surface (N,) ((N,),) 1d-line kamodo.plotting.line_plot ((N,), (N,)) 2d-line-scalar kamodo.plotting.line_plot ((N,), (N,), (N,)) 3d-line-scalar kamodo.plotting.line_plot ((N, 3),) 3d scatter kamodo.plotting.scatter_plot (N, 2) ((N,),) 2d-line kamodo.plotting.line_plot ((N, 2),) 2d-vector kamodo.plotting.vector_plot (N, 3) ((N,),) 3d-line kamodo.plotting.line_plot ((N, 3),) 3d-vector kamodo.plotting.vector_plot ((M,), (M,), (M,)) 3d-tri-surface kamodo.plotting.tri_surface_plot (N, N) ((N,), (N,)) 2d-contour kamodo.plotting.contour_plot (N, M) ((N,), (M,)) 2d-contour kamodo.plotting.contour_plot ((M,), (N,)) 2d-contour kamodo.plotting.contour_plot ((N, M), (N, M)) 2d-contour-skew kamodo.plotting.contour_plot ((N, M), (N, M), (N, M)) 3d-parametric-scalar kamodo.plotting.surface ((1,), (N, M), (N, M)) 3d-plane kamodo.plotting.plane ((N, M), (1,), (N, M)) 3d-plane kamodo.plotting.plane ((N, M), (N, M), (1,)) 3d-plane kamodo.plotting.plane (N, 1, M) ((N,), (1,), (M,)) 3d-plane kamodo.plotting.plane ((1,), (N,), (M,)) 3d-plane kamodo.plotting.plane (1, N, M) ((N,), (1,), (M,)) 3d-plane kamodo.plotting.plane (N, M, 1) ((1,), (N,), (M,)) 3d-plane kamodo.plotting.plane ((N,), (1,), (M,)) 3d-plane kamodo.plotting.plane ((N,), (M,), (1,)) 3d-plane kamodo.plotting.plane ((M,), (N,), (1,)) 3d-plane kamodo.plotting.plane (N, M, 3) ((N,), (M,)) image kamodo.plotting.image When a user tries to plot a given variable, a lookup is made into the table above and the corresponding plotting function is used to generate the output. Examples below demonstrate the intended workflow. 1-Dimensional line plots \u00b6 from kamodo import Kamodo , kamodofy kamodo = Kamodo ( 'g_N[kg] = x_N**2' ) kamodo [ 'f[g]' ] = 'g_N' kamodo \\begin{equation}\\operatorname{g_{N}}{\\left(x_{N} \\right)}[kg] = x_{N}^{2}\\end{equation} \\begin{equation}f{\\left(x_{N} \\right)}[g] = 1000 \\operatorname{g_{N}}{\\left(x_{N} \\right)}\\end{equation} Here we have defined a function \\(g_N\\) which returns an array of shape \\(N\\) . As input, it takes one argument \\(x_N\\) which also has size \\(N\\) . We also generate a function \\(f\\) which is the same as \\(g_N\\) but with a different units. Note We could have named the function \\(g\\) instead of \\(g_N\\) . The variable names have no bearing on the resulting plots - only the argument input shapes and output shapes matter. When we call Kamodo's plot function, we define which variable we are plotting and domain over which the arguments are applied: import numpy as np import plotly.io as pio fig = kamodo . plot ( f = dict ( x_N = np . linspace ( - 4 , 3 , 30 ))) # pio.write_image(fig, 'images/1d-line.svg') This is the graph \\(f(x_n)\\) for \\(x_N \\in [-4,3]\\) . Time series data \u00b6 The process for time series data is the same, except we use a pandas datetime index for the input argument. import pandas as pd t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , verbose = False ) kamodo \\begin{equation}\\rho_{N}{\\left(t_{N} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(t_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'rho_N' ) In this case, we only need to name the variable we wish to plot, because we have already defined a function \\(rho_N(t_N)\\) with a default parameter for \\(t_N\\) . # pio.write_image(fig, 'images/1d-time-series.svg') Note By providing default parameters, the function author can insure that anyone plotting the variable will not need to know where to place resolution! 2-D Parametric charts \u00b6 For 2-D Plots, the output function must have input shape \\((N,1)\\) and output shape \\((N,2)\\) . from kamodo import Kamodo @kamodofy ( units = 'cm' ) def x_Ncomma2 ( theta_N = np . linspace ( 0 , 6 * np . pi , 200 )): r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) return np . array ( list ( zip ( x , y ))) kamodo = Kamodo ( x_Ncomma2 = x_Ncomma2 ) kamodo \\begin{equation}\\operatorname{x_{N,2}}{\\left(\\theta_{N} \\right)}[cm] = \\lambda{\\left(\\theta_{N} \\right)}\\end{equation} Here, we again provide a default array for \\(\\theta_N\\) so the end user does not need to: fig = kamodo . plot ( 'x_Ncomma2' ) # pio.write_image(fig, 'images/fig-2d.svg') 3-Dimensional parametric curves \u00b6 For 3-D parametric curves, the output function must have input shape \\((N,1)\\) and output shape \\((N,3)\\) . @kamodofy ( units = 'km' ) def x_Ncomma3 ( t_N = pd . date_range ( 'Nov 12, 2018' , 'Dec 30, 2018' , freq = '4 H' )): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) theta = dt_days * np . pi / 5 r = theta x = r * np . cos ( theta ) y = r * np . sin ( theta ) z = r return np . array ( list ( zip ( x , y , z ))) kamodo = Kamodo ( x_Ncomma3 = x_Ncomma3 ) kamodo \\begin{equation}\\operatorname{x_{N,3}}{\\left(t_{N} \\right)}[km] = \\lambda{\\left(t_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'x_Ncomma3' ) # pio.write_image(fig, 'images/3d-line.svg') Functions of three N-d arrays are also interpreted as 3D parametric plots, but with an additonal color component. s = np . linspace ( 0 , 8 * np . pi , 100 ) x = 10 * np . sin ( s / 8 ) y = 10 * np . sin ( s ) z = s @kamodofy ( units = 'kg' ) def f_N ( x_N = x , y_N = y , z_N = z ): return x_N ** 2 + y_N ** 2 + z_N ** 2 kamodo = Kamodo ( f_N = f_N ) kamodo \\begin{equation}\\operatorname{f_{N}}{\\left(x_{N},y_{N},z_{N} \\right)}[kg] = \\lambda{\\left(x_{N},y_{N},z_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'f_N' ) # pio.write_image(fig, 'images/3d-points.svg') Vector fields \u00b6 Kamodo generates a 2-d vector (quiver) plot for functions of one variable, if both the input and output have shape (N,2). The input positions are assumed to be \\(x\\) , \\(y\\) and the output vectors are assumed to be \\(v_x\\) , \\(v_y\\) theta_N = np . linspace ( 0 , 6 * np . pi , 200 ) r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) points = np . array ( list ( zip ( x , y ))) @kamodofy ( units = 'cm' ) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): return rvec_Ncomma2 kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo \\begin{equation}\\vec{f}_{N,2}{\\left(\\vec{r}_{N,2} \\right)}[cm] = \\lambda{\\left(\\vec{r}_{N,2} \\right)}\\end{equation} fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector.svg') If we wish to represent a grid of vectors, we must first unravel the grid as a string of points. x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): ux = np . sin ( rvec_Ncomma2 [:, 0 ]) uy = np . cos ( rvec_Ncomma2 [:, 1 ]) return np . vstack (( ux , uy )) . T kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo \\begin{equation}\\vec{f}_{N,2}{\\left(\\vec{r}_{N,2} \\right)} = \\lambda{\\left(\\vec{r}_{N,2} \\right)}\\end{equation} fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector-field.svg') 3D vector fields \u00b6 Functions representing 3D vector fields should have one argument of shape (N,3) and an output shape of (N,3) x , y , z = np . meshgrid ( np . linspace ( - 2 , 2 , 4 ), np . linspace ( - 3 , 3 , 6 ), np . linspace ( - 5 , 5 , 10 )) points = np . array ( list ( zip ( x . ravel (), y . ravel (), z . ravel ()))) def fvec_Ncomma3 ( rvec_Ncomma3 = points ): return rvec_Ncomma3 kamodo = Kamodo ( fvec_Ncomma3 = fvec_Ncomma3 ) kamodo \\begin{equation}\\vec{f}_{N,3}{\\left(\\vec{r}_{N,3} \\right)} = \\lambda{\\left(\\vec{r}_{N,3} \\right)}\\end{equation} fig = kamodo . plot ( 'fvec_Ncomma3' ) # pio.write_image(fig, 'images/fig3d-vector.svg') Contour plots \u00b6 Scalar functions of two variables of size (N) and (M) and output size (N,M) will generate contour plots. Kamodo can handle both ij indexing and xy indexing. from kamodo import Kamodo @kamodofy ( units = 'cm^2' ) def f_NcommaM ( x_N = np . linspace ( 0 , 8 * np . pi , 100 ), y_M = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_M , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NcommaM = f_NcommaM ) kamodo \\begin{equation}\\operatorname{f_{N,M}}{\\left(x_{N},y_{M} \\right)}[cm^{2}] = \\lambda{\\left(x_{N},y_{M} \\right)}\\end{equation} fig = kamodo . plot ( 'f_NcommaM' ) # pio.write_image(fig, 'images/fig2d-contour.svg') Since \\(x_N\\) and \\(y_M\\) have differnt sizes, we could have used indexing=ij as an argument to meshgrid and kamodo would have produced the same figure - Kamodo swaps the ordering where appropriate. In the event that both arguments have the same size, we can pass an indexing argument as an option to the plot function. @kamodofy ( units = 'cm**2' ) def f_NN ( x_N = np . linspace ( 0 , 8 * np . pi , 90 ), y_N = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_N , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NN = f_NN ) kamodo \\begin{equation}\\operatorname{f_{NN}}{\\left(x_{N},y_{N} \\right)}[cm^{2}] = \\lambda{\\left(x_{N},y_{N} \\right)}\\end{equation} fig = kamodo . plot ( f_NN = dict ( indexing = 'xy' )) # pio.write_image(fig, 'images/fig2d-contour-xy.svg') Skew (Carpet) Plots \u00b6 Functions of two arguments each having shape (N,M) matching the output shape will produce skewed contour plots, whereby the x and y components of the grid are independent. r = np . linspace ( 1 , 3 , 20 ) theta = np . linspace ( 0 , np . pi , 14 ) r_ , theta_ = np . meshgrid ( r , theta ) XX = r_ * np . cos ( theta_ ) YY = r_ * np . sin ( theta_ ) @kamodofy ( units = 'cm**2' ) def f_NM ( x_NM = XX , y_NM = YY ): return np . sin ( x_NM ) + y_NM kamodo = Kamodo ( f_NM = f_NM ) kamodo \\begin{equation}\\operatorname{f_{NM}}{\\left(x_{NM},y_{NM} \\right)}[cm^{2}] = \\lambda{\\left(x_{NM},y_{NM} \\right)}\\end{equation} fig = kamodo . plot ( 'f_NM' ) # pio.write_image(fig, 'images/fig2d-skew.svg') Parametric surfaces \u00b6 To generate a purely geometrical parametric surface, supply a functions of three variables, each of size (N,M) and of output shape (1). from kamodo import Kamodo u = np . linspace ( - 2 , 2 , 40 ) v = np . linspace ( - 2 , 2 , 50 ) uu , vv = np . meshgrid ( u , v ) @kamodofy ( units = 'cm' ) def parametric ( x_NM = uu * np . sin ( vv * np . pi ), y_NM = vv , z_NM = np . exp ( - uu ** 2 - vv ** 2 )): return np . array ([ 1 ]) kamodo = Kamodo ( p = parametric ) kamodo \\begin{equation}p{\\left(x_{NM},y_{NM},z_{NM} \\right)}[cm] = \\lambda{\\left(x_{NM},y_{NM},z_{NM} \\right)}\\end{equation} fig = kamodo . plot ( 'p' ) # pio.write_image(fig, 'images/3d-parametric.svg') To control the color of the parametric surface, have the output shape be (N,M). R = 1 theta = np . linspace ( .2 * np . pi , .8 * np . pi , 40 ) phi = np . linspace ( 0 , 2 * np . pi , 50 ) theta_ , phi_ = np . meshgrid ( theta , phi ) r = ( R + .1 * ( np . cos ( 10 * theta_ ) * np . sin ( 14 * phi_ ))) xx = r * np . sin ( theta_ ) * np . cos ( phi_ ) yy = r * np . sin ( theta_ ) * np . sin ( phi_ ) zz = r * np . cos ( theta_ ) @kamodofy ( units = 'cm' ) def spherelike ( x_NM = xx , y_NM = yy , z_NM = zz ): return .1 * x_NM + x_NM ** 2 + y_NM ** 2 + z_NM ** 2 kamodo = Kamodo ( h_NM = spherelike ) kamodo \\begin{equation}\\operatorname{h_{NM}}{\\left(x_{NM},y_{NM},z_{NM} \\right)}[cm] = \\lambda{\\left(x_{NM},y_{NM},z_{NM} \\right)}\\end{equation} fig = kamodo . plot ( 'h_NM' ) # pio.write_image(fig, 'images/3d-parametric-color.svg') Map-to-plane \u00b6 We often need to produce slices through a volumetric grid of data. This may be accomplished through the use of volumetric grid interpolators equipped with default values for each of the input arguments. Suppose such a function has default input arguments of size (L), (M), (N), and output shape (L,M,N), then a cartesian plane will be generated if the user overrides one of these defaults (e.g. setting \\(L = 1\\) ). @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN ) kamodo \\begin{equation}\\operatorname{f_{LMN}}{\\left(x_{L},y_{M},z_{N} \\right)}[\\frac{g}{cm^{3}}] = \\lambda{\\left(x_{L},y_{M},z_{N} \\right)}\\end{equation} fig = kamodo . plot ( f_LMN = dict ( z_N = - 5 )) # pio.write_image(fig,'images/fig2d-map-to-plane.svg') Tip By providing appropriate defaults for the undelying grid structure, the interpolator author can ensure that the user can generate figures with optimal resolution! Multiple traces \u00b6 Kamodo supports multiple traces in the same figure. Simply provide plot with multiple function-argument pairs. from kamodo import Kamodo t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) @kamodofy ( units = 'nPa' ) def p_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( 2 * dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , p_N = p_N , verbose = False ) kamodo \\begin{equation}\\rho_{N}{\\left(t_{N} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(t_{N} \\right)}\\end{equation} \\begin{equation}\\operatorname{p_{N}}{\\left(t_{N} \\right)}[nPa] = \\lambda{\\left(t_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'p_N' , 'rho_N' ) # pio.write_image(fig, 'images/multi-trace.svg') Note Plot types must be compatible for kamodo to plot different variables on the same axes. Kamodo can also handle multiple traces in 3D from kamodo import Kamodo , kamodofy @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN , g_LMN = f_LMN ) kamodo \\begin{equation}\\operatorname{g_{LMN}}{\\left(x_{L},y_{M},z_{N} \\right)}[\\frac{g}{cm^{3}}] = \\lambda{\\left(x_{L},y_{M},z_{N} \\right)}\\end{equation} \\begin{equation}\\operatorname{g_{LMN}}{\\left(x_{L},y_{M},z_{N} \\right)}[\\frac{g}{cm^{3}}] = \\lambda{\\left(x_{L},y_{M},z_{N} \\right)}\\end{equation} fig = kamodo . plot ( f_LMN = dict ( z_N = 0 ), g_LMN = dict ( y_M = 5 )) # pio.write_image(fig, 'images/multi-trace3d.svg') Bug Multiple traces results in different colorbars which may overlap. More control over the layout will be available in future updates. Interactive Plotting \u00b6 For interactive 3d plots, we take advantage of Plotly's in-browser plotting library. from plotly.offline import iplot , plot , init_notebook_mode To generate a separate interactive html page, use iplot instead of plot : # plot(fig, filename = 'sample_plot.html') #uncomment to render 3D interactive plot in this cell navigate to the 3d interactive plot: sample_plot.html . Alternatively, you may work with interactive plots directly in jupyter notebooks: # init_notebook_mode() # uncomment to initialize plotly for notebook # iplot(fig) #uncomment to render 3D interactive plot in this cell Note We have commented out the above lines because they do not render properly on the documentation server, but rest assured they do work!","title":"Visualization"},{"location":"notebooks/Visualization/#visualization","text":"","title":"Visualization"},{"location":"notebooks/Visualization/#overview","text":"Visualization poses a significant challenge for the space weather community: output from models and data are very domain-specific, both in content (coordinate systems, units) and in representation (file formats and data structures). On the other hand, science users also have their preferred context for analyzing these results - for instance, they may only want simulation results interpolated on a satellite trajectory and in a specific coordinate system with their own prefered units. Kamodo aims to strike a balance between the intent of the model (or data) provider and the goals of the user, by making it easy for developers to provide context for their output and for users to easily change that context. It accomplishes this in two ways: By leveraging default arguments given by model and data providers By mapping the shape of function inputs and output to certain registered plot types This strategy allows Kamodo to automatically generate plots for arbitrary model output and data sources, while still allowing for customization by the end user.","title":"Overview"},{"location":"notebooks/Visualization/#available-plot-types","text":"Kamodo keeps a registry of plotting functions, indexed by argument shape and output shape. from kamodo.plotting import plot_types plot_types .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } plot_type function out_shape arg_shapes (1,) ((N, M), (N, M), (N, M)) 3d-parametric kamodo.plotting.surface (N,) ((N,),) 1d-line kamodo.plotting.line_plot ((N,), (N,)) 2d-line-scalar kamodo.plotting.line_plot ((N,), (N,), (N,)) 3d-line-scalar kamodo.plotting.line_plot ((N, 3),) 3d scatter kamodo.plotting.scatter_plot (N, 2) ((N,),) 2d-line kamodo.plotting.line_plot ((N, 2),) 2d-vector kamodo.plotting.vector_plot (N, 3) ((N,),) 3d-line kamodo.plotting.line_plot ((N, 3),) 3d-vector kamodo.plotting.vector_plot ((M,), (M,), (M,)) 3d-tri-surface kamodo.plotting.tri_surface_plot (N, N) ((N,), (N,)) 2d-contour kamodo.plotting.contour_plot (N, M) ((N,), (M,)) 2d-contour kamodo.plotting.contour_plot ((M,), (N,)) 2d-contour kamodo.plotting.contour_plot ((N, M), (N, M)) 2d-contour-skew kamodo.plotting.contour_plot ((N, M), (N, M), (N, M)) 3d-parametric-scalar kamodo.plotting.surface ((1,), (N, M), (N, M)) 3d-plane kamodo.plotting.plane ((N, M), (1,), (N, M)) 3d-plane kamodo.plotting.plane ((N, M), (N, M), (1,)) 3d-plane kamodo.plotting.plane (N, 1, M) ((N,), (1,), (M,)) 3d-plane kamodo.plotting.plane ((1,), (N,), (M,)) 3d-plane kamodo.plotting.plane (1, N, M) ((N,), (1,), (M,)) 3d-plane kamodo.plotting.plane (N, M, 1) ((1,), (N,), (M,)) 3d-plane kamodo.plotting.plane ((N,), (1,), (M,)) 3d-plane kamodo.plotting.plane ((N,), (M,), (1,)) 3d-plane kamodo.plotting.plane ((M,), (N,), (1,)) 3d-plane kamodo.plotting.plane (N, M, 3) ((N,), (M,)) image kamodo.plotting.image When a user tries to plot a given variable, a lookup is made into the table above and the corresponding plotting function is used to generate the output. Examples below demonstrate the intended workflow.","title":"Available Plot Types"},{"location":"notebooks/Visualization/#1-dimensional-line-plots","text":"from kamodo import Kamodo , kamodofy kamodo = Kamodo ( 'g_N[kg] = x_N**2' ) kamodo [ 'f[g]' ] = 'g_N' kamodo \\begin{equation}\\operatorname{g_{N}}{\\left(x_{N} \\right)}[kg] = x_{N}^{2}\\end{equation} \\begin{equation}f{\\left(x_{N} \\right)}[g] = 1000 \\operatorname{g_{N}}{\\left(x_{N} \\right)}\\end{equation} Here we have defined a function \\(g_N\\) which returns an array of shape \\(N\\) . As input, it takes one argument \\(x_N\\) which also has size \\(N\\) . We also generate a function \\(f\\) which is the same as \\(g_N\\) but with a different units. Note We could have named the function \\(g\\) instead of \\(g_N\\) . The variable names have no bearing on the resulting plots - only the argument input shapes and output shapes matter. When we call Kamodo's plot function, we define which variable we are plotting and domain over which the arguments are applied: import numpy as np import plotly.io as pio fig = kamodo . plot ( f = dict ( x_N = np . linspace ( - 4 , 3 , 30 ))) # pio.write_image(fig, 'images/1d-line.svg') This is the graph \\(f(x_n)\\) for \\(x_N \\in [-4,3]\\) .","title":"1-Dimensional line plots"},{"location":"notebooks/Visualization/#time-series-data","text":"The process for time series data is the same, except we use a pandas datetime index for the input argument. import pandas as pd t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , verbose = False ) kamodo \\begin{equation}\\rho_{N}{\\left(t_{N} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(t_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'rho_N' ) In this case, we only need to name the variable we wish to plot, because we have already defined a function \\(rho_N(t_N)\\) with a default parameter for \\(t_N\\) . # pio.write_image(fig, 'images/1d-time-series.svg') Note By providing default parameters, the function author can insure that anyone plotting the variable will not need to know where to place resolution!","title":"Time series data"},{"location":"notebooks/Visualization/#2-d-parametric-charts","text":"For 2-D Plots, the output function must have input shape \\((N,1)\\) and output shape \\((N,2)\\) . from kamodo import Kamodo @kamodofy ( units = 'cm' ) def x_Ncomma2 ( theta_N = np . linspace ( 0 , 6 * np . pi , 200 )): r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) return np . array ( list ( zip ( x , y ))) kamodo = Kamodo ( x_Ncomma2 = x_Ncomma2 ) kamodo \\begin{equation}\\operatorname{x_{N,2}}{\\left(\\theta_{N} \\right)}[cm] = \\lambda{\\left(\\theta_{N} \\right)}\\end{equation} Here, we again provide a default array for \\(\\theta_N\\) so the end user does not need to: fig = kamodo . plot ( 'x_Ncomma2' ) # pio.write_image(fig, 'images/fig-2d.svg')","title":"2-D Parametric charts"},{"location":"notebooks/Visualization/#3-dimensional-parametric-curves","text":"For 3-D parametric curves, the output function must have input shape \\((N,1)\\) and output shape \\((N,3)\\) . @kamodofy ( units = 'km' ) def x_Ncomma3 ( t_N = pd . date_range ( 'Nov 12, 2018' , 'Dec 30, 2018' , freq = '4 H' )): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) theta = dt_days * np . pi / 5 r = theta x = r * np . cos ( theta ) y = r * np . sin ( theta ) z = r return np . array ( list ( zip ( x , y , z ))) kamodo = Kamodo ( x_Ncomma3 = x_Ncomma3 ) kamodo \\begin{equation}\\operatorname{x_{N,3}}{\\left(t_{N} \\right)}[km] = \\lambda{\\left(t_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'x_Ncomma3' ) # pio.write_image(fig, 'images/3d-line.svg') Functions of three N-d arrays are also interpreted as 3D parametric plots, but with an additonal color component. s = np . linspace ( 0 , 8 * np . pi , 100 ) x = 10 * np . sin ( s / 8 ) y = 10 * np . sin ( s ) z = s @kamodofy ( units = 'kg' ) def f_N ( x_N = x , y_N = y , z_N = z ): return x_N ** 2 + y_N ** 2 + z_N ** 2 kamodo = Kamodo ( f_N = f_N ) kamodo \\begin{equation}\\operatorname{f_{N}}{\\left(x_{N},y_{N},z_{N} \\right)}[kg] = \\lambda{\\left(x_{N},y_{N},z_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'f_N' ) # pio.write_image(fig, 'images/3d-points.svg')","title":"3-Dimensional parametric curves"},{"location":"notebooks/Visualization/#vector-fields","text":"Kamodo generates a 2-d vector (quiver) plot for functions of one variable, if both the input and output have shape (N,2). The input positions are assumed to be \\(x\\) , \\(y\\) and the output vectors are assumed to be \\(v_x\\) , \\(v_y\\) theta_N = np . linspace ( 0 , 6 * np . pi , 200 ) r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) points = np . array ( list ( zip ( x , y ))) @kamodofy ( units = 'cm' ) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): return rvec_Ncomma2 kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo \\begin{equation}\\vec{f}_{N,2}{\\left(\\vec{r}_{N,2} \\right)}[cm] = \\lambda{\\left(\\vec{r}_{N,2} \\right)}\\end{equation} fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector.svg') If we wish to represent a grid of vectors, we must first unravel the grid as a string of points. x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): ux = np . sin ( rvec_Ncomma2 [:, 0 ]) uy = np . cos ( rvec_Ncomma2 [:, 1 ]) return np . vstack (( ux , uy )) . T kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo \\begin{equation}\\vec{f}_{N,2}{\\left(\\vec{r}_{N,2} \\right)} = \\lambda{\\left(\\vec{r}_{N,2} \\right)}\\end{equation} fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector-field.svg')","title":"Vector fields"},{"location":"notebooks/Visualization/#3d-vector-fields","text":"Functions representing 3D vector fields should have one argument of shape (N,3) and an output shape of (N,3) x , y , z = np . meshgrid ( np . linspace ( - 2 , 2 , 4 ), np . linspace ( - 3 , 3 , 6 ), np . linspace ( - 5 , 5 , 10 )) points = np . array ( list ( zip ( x . ravel (), y . ravel (), z . ravel ()))) def fvec_Ncomma3 ( rvec_Ncomma3 = points ): return rvec_Ncomma3 kamodo = Kamodo ( fvec_Ncomma3 = fvec_Ncomma3 ) kamodo \\begin{equation}\\vec{f}_{N,3}{\\left(\\vec{r}_{N,3} \\right)} = \\lambda{\\left(\\vec{r}_{N,3} \\right)}\\end{equation} fig = kamodo . plot ( 'fvec_Ncomma3' ) # pio.write_image(fig, 'images/fig3d-vector.svg')","title":"3D vector fields"},{"location":"notebooks/Visualization/#contour-plots","text":"Scalar functions of two variables of size (N) and (M) and output size (N,M) will generate contour plots. Kamodo can handle both ij indexing and xy indexing. from kamodo import Kamodo @kamodofy ( units = 'cm^2' ) def f_NcommaM ( x_N = np . linspace ( 0 , 8 * np . pi , 100 ), y_M = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_M , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NcommaM = f_NcommaM ) kamodo \\begin{equation}\\operatorname{f_{N,M}}{\\left(x_{N},y_{M} \\right)}[cm^{2}] = \\lambda{\\left(x_{N},y_{M} \\right)}\\end{equation} fig = kamodo . plot ( 'f_NcommaM' ) # pio.write_image(fig, 'images/fig2d-contour.svg') Since \\(x_N\\) and \\(y_M\\) have differnt sizes, we could have used indexing=ij as an argument to meshgrid and kamodo would have produced the same figure - Kamodo swaps the ordering where appropriate. In the event that both arguments have the same size, we can pass an indexing argument as an option to the plot function. @kamodofy ( units = 'cm**2' ) def f_NN ( x_N = np . linspace ( 0 , 8 * np . pi , 90 ), y_N = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_N , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NN = f_NN ) kamodo \\begin{equation}\\operatorname{f_{NN}}{\\left(x_{N},y_{N} \\right)}[cm^{2}] = \\lambda{\\left(x_{N},y_{N} \\right)}\\end{equation} fig = kamodo . plot ( f_NN = dict ( indexing = 'xy' )) # pio.write_image(fig, 'images/fig2d-contour-xy.svg')","title":"Contour plots"},{"location":"notebooks/Visualization/#skew-carpet-plots","text":"Functions of two arguments each having shape (N,M) matching the output shape will produce skewed contour plots, whereby the x and y components of the grid are independent. r = np . linspace ( 1 , 3 , 20 ) theta = np . linspace ( 0 , np . pi , 14 ) r_ , theta_ = np . meshgrid ( r , theta ) XX = r_ * np . cos ( theta_ ) YY = r_ * np . sin ( theta_ ) @kamodofy ( units = 'cm**2' ) def f_NM ( x_NM = XX , y_NM = YY ): return np . sin ( x_NM ) + y_NM kamodo = Kamodo ( f_NM = f_NM ) kamodo \\begin{equation}\\operatorname{f_{NM}}{\\left(x_{NM},y_{NM} \\right)}[cm^{2}] = \\lambda{\\left(x_{NM},y_{NM} \\right)}\\end{equation} fig = kamodo . plot ( 'f_NM' ) # pio.write_image(fig, 'images/fig2d-skew.svg')","title":"Skew (Carpet) Plots"},{"location":"notebooks/Visualization/#parametric-surfaces","text":"To generate a purely geometrical parametric surface, supply a functions of three variables, each of size (N,M) and of output shape (1). from kamodo import Kamodo u = np . linspace ( - 2 , 2 , 40 ) v = np . linspace ( - 2 , 2 , 50 ) uu , vv = np . meshgrid ( u , v ) @kamodofy ( units = 'cm' ) def parametric ( x_NM = uu * np . sin ( vv * np . pi ), y_NM = vv , z_NM = np . exp ( - uu ** 2 - vv ** 2 )): return np . array ([ 1 ]) kamodo = Kamodo ( p = parametric ) kamodo \\begin{equation}p{\\left(x_{NM},y_{NM},z_{NM} \\right)}[cm] = \\lambda{\\left(x_{NM},y_{NM},z_{NM} \\right)}\\end{equation} fig = kamodo . plot ( 'p' ) # pio.write_image(fig, 'images/3d-parametric.svg') To control the color of the parametric surface, have the output shape be (N,M). R = 1 theta = np . linspace ( .2 * np . pi , .8 * np . pi , 40 ) phi = np . linspace ( 0 , 2 * np . pi , 50 ) theta_ , phi_ = np . meshgrid ( theta , phi ) r = ( R + .1 * ( np . cos ( 10 * theta_ ) * np . sin ( 14 * phi_ ))) xx = r * np . sin ( theta_ ) * np . cos ( phi_ ) yy = r * np . sin ( theta_ ) * np . sin ( phi_ ) zz = r * np . cos ( theta_ ) @kamodofy ( units = 'cm' ) def spherelike ( x_NM = xx , y_NM = yy , z_NM = zz ): return .1 * x_NM + x_NM ** 2 + y_NM ** 2 + z_NM ** 2 kamodo = Kamodo ( h_NM = spherelike ) kamodo \\begin{equation}\\operatorname{h_{NM}}{\\left(x_{NM},y_{NM},z_{NM} \\right)}[cm] = \\lambda{\\left(x_{NM},y_{NM},z_{NM} \\right)}\\end{equation} fig = kamodo . plot ( 'h_NM' ) # pio.write_image(fig, 'images/3d-parametric-color.svg')","title":"Parametric surfaces"},{"location":"notebooks/Visualization/#map-to-plane","text":"We often need to produce slices through a volumetric grid of data. This may be accomplished through the use of volumetric grid interpolators equipped with default values for each of the input arguments. Suppose such a function has default input arguments of size (L), (M), (N), and output shape (L,M,N), then a cartesian plane will be generated if the user overrides one of these defaults (e.g. setting \\(L = 1\\) ). @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN ) kamodo \\begin{equation}\\operatorname{f_{LMN}}{\\left(x_{L},y_{M},z_{N} \\right)}[\\frac{g}{cm^{3}}] = \\lambda{\\left(x_{L},y_{M},z_{N} \\right)}\\end{equation} fig = kamodo . plot ( f_LMN = dict ( z_N = - 5 )) # pio.write_image(fig,'images/fig2d-map-to-plane.svg') Tip By providing appropriate defaults for the undelying grid structure, the interpolator author can ensure that the user can generate figures with optimal resolution!","title":"Map-to-plane"},{"location":"notebooks/Visualization/#multiple-traces","text":"Kamodo supports multiple traces in the same figure. Simply provide plot with multiple function-argument pairs. from kamodo import Kamodo t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) @kamodofy ( units = 'nPa' ) def p_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( 2 * dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , p_N = p_N , verbose = False ) kamodo \\begin{equation}\\rho_{N}{\\left(t_{N} \\right)}[\\frac{kg}{m^{3}}] = \\lambda{\\left(t_{N} \\right)}\\end{equation} \\begin{equation}\\operatorname{p_{N}}{\\left(t_{N} \\right)}[nPa] = \\lambda{\\left(t_{N} \\right)}\\end{equation} fig = kamodo . plot ( 'p_N' , 'rho_N' ) # pio.write_image(fig, 'images/multi-trace.svg') Note Plot types must be compatible for kamodo to plot different variables on the same axes. Kamodo can also handle multiple traces in 3D from kamodo import Kamodo , kamodofy @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN , g_LMN = f_LMN ) kamodo \\begin{equation}\\operatorname{g_{LMN}}{\\left(x_{L},y_{M},z_{N} \\right)}[\\frac{g}{cm^{3}}] = \\lambda{\\left(x_{L},y_{M},z_{N} \\right)}\\end{equation} \\begin{equation}\\operatorname{g_{LMN}}{\\left(x_{L},y_{M},z_{N} \\right)}[\\frac{g}{cm^{3}}] = \\lambda{\\left(x_{L},y_{M},z_{N} \\right)}\\end{equation} fig = kamodo . plot ( f_LMN = dict ( z_N = 0 ), g_LMN = dict ( y_M = 5 )) # pio.write_image(fig, 'images/multi-trace3d.svg') Bug Multiple traces results in different colorbars which may overlap. More control over the layout will be available in future updates.","title":"Multiple traces"},{"location":"notebooks/Visualization/#interactive-plotting","text":"For interactive 3d plots, we take advantage of Plotly's in-browser plotting library. from plotly.offline import iplot , plot , init_notebook_mode To generate a separate interactive html page, use iplot instead of plot : # plot(fig, filename = 'sample_plot.html') #uncomment to render 3D interactive plot in this cell navigate to the 3d interactive plot: sample_plot.html . Alternatively, you may work with interactive plots directly in jupyter notebooks: # init_notebook_mode() # uncomment to initialize plotly for notebook # iplot(fig) #uncomment to render 3D interactive plot in this cell Note We have commented out the above lines because they do not render properly on the documentation server, but rest assured they do work!","title":"Interactive Plotting"},{"location":"notebooks/Weierstrass/","text":"from kamodo import Kamodo , kamodofy import numpy as np @kamodofy ( equation = r \"\\sum_{n=0}^ {500} (1/2)^n cos(3^n \\pi x)\" , citation = 'Weierstrass, K. (1872). Uber continuirliche functionen eines reellen arguments, die fur keinen worth des letzteren einen bestimmten differentailqutienten besitzen, Akademievortrag. Math. Werke, 71-74.' ) def weierstrass ( x = np . linspace ( - 2 , 2 , 1000 )): ''' Weierstrass function A continuous non-differentiable https://en.wikipedia.org/wiki/Weierstrass_function ''' nmax = 500 n = np . arange ( nmax ) xx , nn = np . meshgrid ( x , n ) ww = ( .5 ) ** nn * np . cos ( 3 ** nn * np . pi * xx ) return ww . sum ( axis = 0 ) k = Kamodo ( W = weierstrass ) k k . to_latex () k . W ( 0.25 ) fig = k . plot ( 'W' ) fig fig . write_image ( 'weirstrass.png' , scale = 2 )","title":"Weierstrass"}]}