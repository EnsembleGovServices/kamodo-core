{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kamodo \u00b6 Kamodo is a CCMC tool for access, interpolation, and visualization of space weather models and data in python. Kamodo allows model developers to represent simulation results as mathematical functions which may be manipulated directly by end users. Kamodo handles unit conversion transparently and supports interactive science discovery through jupyter notebooks with minimal coding and is accessible through python. The project page is located at the Community Coordinated Modeling Center, located at NASA Goddard Space Flight Center. Official site page https://ccmc.gsfc.nasa.gov/Kamodo/ Kamodo's official source code is hosted on github under a permissive NASA open source license: https://github.com/nasa/Kamodo Periodic contributions to Kamodo are made from the unofficial repo located here https://github.com/asherp/Kamodo Usage \u00b6 Suppose we have a vector field defined by a function of positions in the x-y plane: from kamodo import kamodofy import numpy as np x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( zip ( xx . ravel (), yy . ravel ())) @kamodofy ( units = 'km/s' ) def fvec ( rvec = points ): ux = np . sin ( rvec [:, 0 ]) uy = np . cos ( rvec [:, 1 ]) return np . vstack (( ux , uy )) . T The @kamodofy decorator lets us register this field with units to enable unit-conversion downstream: from kamodo import Kamodo kamodo = Kamodo ( fvec = fvec ) kamodo When run in a jupyter notebook, the above kamodo object will render as a set of equations: \\vec{f}{\\left (\\vec{r} \\right )} [km/s] = \\lambda{\\left (\\vec{r} \\right )} We can now evaluate our function using dot notation: kamodo . fvec ( np . array ([[ - 1 , 1 ]])) array([[-0.84147098, 0.54030231]]) We can perform unit conversion by function composition: kamodo [ 'gvec[m/s]' ] = 'fvec' kamodo automatically generates the appropriate multiplicative factors: \\vec{g}{\\left (\\vec{r} \\right )} [m/s] = 1000 \\vec{f}{\\left (\\vec{r} \\right )} we can verify these results through evaluation kamodo . gvec ( np . array ([[ - 1 , 1 ]])) array([[-841.47098481, 540.30230587]]) Kamodo also generates quick-look graphics via function inspection. import plotly.io as pio fig = kamodo . plot ( 'fvec' ) pio . write_image ( fig , 'images/fig2d-usage.svg' ) Head over to the Introduction page for more details. Getting started \u00b6 Kamodo may be installed from pip pip install kamodo To get the latest version, install from Asher's fork: pip install git+https://github.com/asherp/Kamodo.git Note Asher's fork is periodically merged into the CCMC's official NASA version. Kamodo Environment \u00b6 We strongly recommend using the conda environment system to avoid library conflicts with your host machine's python. Download and install miniconda from here . The advantage to using miniconda is that each new environment includes the bare-minimum for a project. This allows you to keep many different projects on a single work station. Create Kamodo environment \u00b6 Create a new environment for kamodo conda create -n kamodo python==3.7 conda activate kamodo (kamodo) pip install kamodo Note The leading (kamodo) in your prompt indicates that you have activated the kamodo environment. From here on, anything you install will be isolated to the kamodo environment. Loading example notebooks \u00b6 If you want to run any of the notebooks in docs, you will need to install jupyter : (kamodo) conda install jupyter Navigate to the top-level of the kamodo repo, then point jupyter to docs/notebooks : (kamodo) jupyter notebook docs/notebooks This should open a browser window that will allow you to load any of the example notebooks. Requirements \u00b6 The following requirements are obtained by running pip install kamodo numpy scipy sympy pandas plotly==3.3 pytest psutil conda install antlr-python-runtime (rendering latex) conda install -c plotly plotly-orca (for writing images) Note plotly version in flux Generating Docs \u00b6 Kamodo's documentation site is a good example of how to embed your own plots in your own website. The documentation site is generated by the mkdocs package with some addons mkdocs - handles site generation and deployment (configured by top-level mkdocs.yaml ) markdown-include - allows for embedding of markdown files (and graph divs) outside the docs folder python-markdown-math - enables LaTeX rendering mknotebooks - allows for the embedding of jupyter notebooks All of the above requirements can be installed with this line: pip install mkdocs python-markdown-math markdown-include mknotebooks You can then generate the docs and serve locally with mkdocs serve To deploy your own documentation on github-pages: mkdocs gh-deploy This generates a gh-pages branch with the static site files and pushes it to github. Github automatically creates a website url based on that branch.","title":"Home"},{"location":"#kamodo","text":"Kamodo is a CCMC tool for access, interpolation, and visualization of space weather models and data in python. Kamodo allows model developers to represent simulation results as mathematical functions which may be manipulated directly by end users. Kamodo handles unit conversion transparently and supports interactive science discovery through jupyter notebooks with minimal coding and is accessible through python. The project page is located at the Community Coordinated Modeling Center, located at NASA Goddard Space Flight Center. Official site page https://ccmc.gsfc.nasa.gov/Kamodo/ Kamodo's official source code is hosted on github under a permissive NASA open source license: https://github.com/nasa/Kamodo Periodic contributions to Kamodo are made from the unofficial repo located here https://github.com/asherp/Kamodo","title":"Kamodo"},{"location":"#usage","text":"Suppose we have a vector field defined by a function of positions in the x-y plane: from kamodo import kamodofy import numpy as np x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( zip ( xx . ravel (), yy . ravel ())) @kamodofy ( units = 'km/s' ) def fvec ( rvec = points ): ux = np . sin ( rvec [:, 0 ]) uy = np . cos ( rvec [:, 1 ]) return np . vstack (( ux , uy )) . T The @kamodofy decorator lets us register this field with units to enable unit-conversion downstream: from kamodo import Kamodo kamodo = Kamodo ( fvec = fvec ) kamodo When run in a jupyter notebook, the above kamodo object will render as a set of equations: \\vec{f}{\\left (\\vec{r} \\right )} [km/s] = \\lambda{\\left (\\vec{r} \\right )} We can now evaluate our function using dot notation: kamodo . fvec ( np . array ([[ - 1 , 1 ]])) array([[-0.84147098, 0.54030231]]) We can perform unit conversion by function composition: kamodo [ 'gvec[m/s]' ] = 'fvec' kamodo automatically generates the appropriate multiplicative factors: \\vec{g}{\\left (\\vec{r} \\right )} [m/s] = 1000 \\vec{f}{\\left (\\vec{r} \\right )} we can verify these results through evaluation kamodo . gvec ( np . array ([[ - 1 , 1 ]])) array([[-841.47098481, 540.30230587]]) Kamodo also generates quick-look graphics via function inspection. import plotly.io as pio fig = kamodo . plot ( 'fvec' ) pio . write_image ( fig , 'images/fig2d-usage.svg' ) Head over to the Introduction page for more details.","title":"Usage"},{"location":"#getting-started","text":"Kamodo may be installed from pip pip install kamodo To get the latest version, install from Asher's fork: pip install git+https://github.com/asherp/Kamodo.git Note Asher's fork is periodically merged into the CCMC's official NASA version.","title":"Getting started"},{"location":"#kamodo-environment","text":"We strongly recommend using the conda environment system to avoid library conflicts with your host machine's python. Download and install miniconda from here . The advantage to using miniconda is that each new environment includes the bare-minimum for a project. This allows you to keep many different projects on a single work station.","title":"Kamodo Environment"},{"location":"#create-kamodo-environment","text":"Create a new environment for kamodo conda create -n kamodo python==3.7 conda activate kamodo (kamodo) pip install kamodo Note The leading (kamodo) in your prompt indicates that you have activated the kamodo environment. From here on, anything you install will be isolated to the kamodo environment.","title":"Create Kamodo environment"},{"location":"#loading-example-notebooks","text":"If you want to run any of the notebooks in docs, you will need to install jupyter : (kamodo) conda install jupyter Navigate to the top-level of the kamodo repo, then point jupyter to docs/notebooks : (kamodo) jupyter notebook docs/notebooks This should open a browser window that will allow you to load any of the example notebooks.","title":"Loading example notebooks"},{"location":"#requirements","text":"The following requirements are obtained by running pip install kamodo numpy scipy sympy pandas plotly==3.3 pytest psutil conda install antlr-python-runtime (rendering latex) conda install -c plotly plotly-orca (for writing images) Note plotly version in flux","title":"Requirements"},{"location":"#generating-docs","text":"Kamodo's documentation site is a good example of how to embed your own plots in your own website. The documentation site is generated by the mkdocs package with some addons mkdocs - handles site generation and deployment (configured by top-level mkdocs.yaml ) markdown-include - allows for embedding of markdown files (and graph divs) outside the docs folder python-markdown-math - enables LaTeX rendering mknotebooks - allows for the embedding of jupyter notebooks All of the above requirements can be installed with this line: pip install mkdocs python-markdown-math markdown-include mknotebooks You can then generate the docs and serve locally with mkdocs serve To deploy your own documentation on github-pages: mkdocs gh-deploy This generates a gh-pages branch with the static site files and pushes it to github. Github automatically creates a website url based on that branch.","title":"Generating Docs"},{"location":"API/","text":"API documentation \u00b6 Kamodo \u00b6 class kamodo. Kamodo ( *funcs , **kwargs ) Kamodo base class demonstrating common API for space weather models This API provides access to space weather fields and their properties through: interpolation of variables at user-defined points unit conversions coordinate transformations specific to space weather domains Required methods that have not been implemented in child classes will raise a NotImplementedError init ( self , *funcs , **kwargs ) Base initialization method Args: param1 (str, optional): Filename of datafile to interpolate from setitem ( self , sym_name , input_expr ) Assigns a function or expression to a new symbol, performs unit conversion where appropriate getitem ( self , key ) plot ( self , *variables , plot_partial={} , **figures ) figure ( self , variable , indexing='ij' , **kwargs ) Generates a plotly figure for a given variable and keyword arguments to_latex ( self , keys=None , mode='equation' ) Generate list of LaTeX-formated formulas Upon registeration, each function should have a repr_latex method. repr_latex ( self ) Provide notebook rendering of formulas detail ( self ) Constructs a pandas dataframe from signatures evaluate ( self , variable , *args , **kwargs ) evaluates the variable if the variable is not present, try to parse it as a semicolon-delimited list Plotting \u00b6 Plot types \u00b6 As described in Visualization , Kamodo automatically maps registered functions to certain plot types. All such functions expect the same input variables and return a triplet [trace], chart_type, layout where [trace] is a list of plotly trace objects. kamodo.plotting. get_plot_types_df ( ) pack the plot types into a dataframe The available plot types may be imported thusly: from kamodo.plotting import plot_types Scatter plot \u00b6 kamodo.plotting. scatter_plot ( result , titles , verbose=False , **kwargs ) Generates a 3d scatter plot result: a dictionary of parameters titles: a dictionary of titles returns: [trace], chart_type, layout Line plot \u00b6 kamodo.plotting. line_plot ( result , titles , verbose=False , **kwargs ) N-d line plot f(t) Vector plot \u00b6 kamodo.plotting. vector_plot ( result , titles , verbose=False , **kwargs ) Contour plot \u00b6 kamodo.plotting. contour_plot ( result , titles , indexing , verbose=False , **kwargs ) 3D Plane \u00b6 kamodo.plotting. plane ( result , titles , indexing='xy' , verbose=False , **kwargs ) 3D Surface \u00b6 kamodo.plotting. surface ( result , titles , verbose=False , **kwargs ) Carpet plot \u00b6 kamodo.plotting. carpet_plot ( results , title , xaxis , yaxis , indexing='xy' , **kwargs ) Assumes ordered dict where values have the same shape Triangulated Mesh plot \u00b6 kamodo.plotting. tri_surface_plot ( result , titles , verbose=False , **kwargs ) Image plot \u00b6 kamodo.plotting. image ( result , titles , verbose=False , **kwargs ) Decorators \u00b6 These decorators may also be imported like this from kamodo import kamodofy kamodofy \u00b6 kamodo.util. kamodofy ( _func=None , units='' , arg_units=None , data=None , update=None , equation=None , citation=None , hidden_args=[] , **kwargs ) Adds meta and data attributes to functions for compatibility with Komodo meta: a dictionary containing {units: } data: if supplied, set f.data = data if not supplied, set f.data = f(), assuming it can be called with no arguments. If f cannot be called with no arguments, set f.data = None Usage: @kamodofy ( units = 'kg/cm^2' , arg_units = dict ( x = 'cm' ), citation = 'Pembroke et. al 2022' , hidden_args = [ 'verbose' ]) def myfunc ( x = 30 , verbose = True ): return x ** 2 myfunc . meta {'units': 'kg/cm^2', 'arg_units': {'x': 'cm'}, 'citation': 'Pembroke et. al 2022', 'equation': None, 'hidden_args': ['verbose']} The above metadata is used by Kamodo objects for function registration. Similarly, a data attribute is attached which represents the output of the function when called with no arguments: myfunc . data 900 kamodo.util. gridify ( _func=None , order='A' , squeeze=True , **defaults ) Given a function of shape (n,dim) and arguments of shape (L), (M), calls f with points L*M order: 'A' (default) uses indexing='xy' in meshgrid 'C' uses indexing='ij' in meshgrid squeeze: True (default) passed to reshape before returning pointlike \u00b6 kamodo.util. pointlike ( _func=None , signature=None , otypes=[ ] , squeeze=None ) Transforms a single-argument function to one that accepts m points of dimension n partial \u00b6 kamodo.util. partial ( _func=None , **partial_kwargs ) A partial function decorator Reduces function signature to reflect partially assigned kwargs","title":"API"},{"location":"API/#api-documentation","text":"","title":"API documentation"},{"location":"API/#kamodo","text":"class kamodo. Kamodo ( *funcs , **kwargs ) Kamodo base class demonstrating common API for space weather models This API provides access to space weather fields and their properties through: interpolation of variables at user-defined points unit conversions coordinate transformations specific to space weather domains Required methods that have not been implemented in child classes will raise a NotImplementedError init ( self , *funcs , **kwargs ) Base initialization method Args: param1 (str, optional): Filename of datafile to interpolate from setitem ( self , sym_name , input_expr ) Assigns a function or expression to a new symbol, performs unit conversion where appropriate getitem ( self , key ) plot ( self , *variables , plot_partial={} , **figures ) figure ( self , variable , indexing='ij' , **kwargs ) Generates a plotly figure for a given variable and keyword arguments to_latex ( self , keys=None , mode='equation' ) Generate list of LaTeX-formated formulas Upon registeration, each function should have a repr_latex method. repr_latex ( self ) Provide notebook rendering of formulas detail ( self ) Constructs a pandas dataframe from signatures evaluate ( self , variable , *args , **kwargs ) evaluates the variable if the variable is not present, try to parse it as a semicolon-delimited list","title":"Kamodo"},{"location":"API/#plotting","text":"","title":"Plotting"},{"location":"API/#plot-types","text":"As described in Visualization , Kamodo automatically maps registered functions to certain plot types. All such functions expect the same input variables and return a triplet [trace], chart_type, layout where [trace] is a list of plotly trace objects. kamodo.plotting. get_plot_types_df ( ) pack the plot types into a dataframe The available plot types may be imported thusly: from kamodo.plotting import plot_types","title":"Plot types"},{"location":"API/#scatter-plot","text":"kamodo.plotting. scatter_plot ( result , titles , verbose=False , **kwargs ) Generates a 3d scatter plot result: a dictionary of parameters titles: a dictionary of titles returns: [trace], chart_type, layout","title":"Scatter plot"},{"location":"API/#line-plot","text":"kamodo.plotting. line_plot ( result , titles , verbose=False , **kwargs ) N-d line plot f(t)","title":"Line plot"},{"location":"API/#vector-plot","text":"kamodo.plotting. vector_plot ( result , titles , verbose=False , **kwargs )","title":"Vector plot"},{"location":"API/#contour-plot","text":"kamodo.plotting. contour_plot ( result , titles , indexing , verbose=False , **kwargs )","title":"Contour plot"},{"location":"API/#3d-plane","text":"kamodo.plotting. plane ( result , titles , indexing='xy' , verbose=False , **kwargs )","title":"3D Plane"},{"location":"API/#3d-surface","text":"kamodo.plotting. surface ( result , titles , verbose=False , **kwargs )","title":"3D Surface"},{"location":"API/#carpet-plot","text":"kamodo.plotting. carpet_plot ( results , title , xaxis , yaxis , indexing='xy' , **kwargs ) Assumes ordered dict where values have the same shape","title":"Carpet plot"},{"location":"API/#triangulated-mesh-plot","text":"kamodo.plotting. tri_surface_plot ( result , titles , verbose=False , **kwargs )","title":"Triangulated Mesh plot"},{"location":"API/#image-plot","text":"kamodo.plotting. image ( result , titles , verbose=False , **kwargs )","title":"Image plot"},{"location":"API/#decorators","text":"These decorators may also be imported like this from kamodo import kamodofy","title":"Decorators"},{"location":"API/#kamodofy","text":"kamodo.util. kamodofy ( _func=None , units='' , arg_units=None , data=None , update=None , equation=None , citation=None , hidden_args=[] , **kwargs ) Adds meta and data attributes to functions for compatibility with Komodo meta: a dictionary containing {units: } data: if supplied, set f.data = data if not supplied, set f.data = f(), assuming it can be called with no arguments. If f cannot be called with no arguments, set f.data = None Usage: @kamodofy ( units = 'kg/cm^2' , arg_units = dict ( x = 'cm' ), citation = 'Pembroke et. al 2022' , hidden_args = [ 'verbose' ]) def myfunc ( x = 30 , verbose = True ): return x ** 2 myfunc . meta {'units': 'kg/cm^2', 'arg_units': {'x': 'cm'}, 'citation': 'Pembroke et. al 2022', 'equation': None, 'hidden_args': ['verbose']} The above metadata is used by Kamodo objects for function registration. Similarly, a data attribute is attached which represents the output of the function when called with no arguments: myfunc . data 900 kamodo.util. gridify ( _func=None , order='A' , squeeze=True , **defaults ) Given a function of shape (n,dim) and arguments of shape (L), (M), calls f with points L*M order: 'A' (default) uses indexing='xy' in meshgrid 'C' uses indexing='ij' in meshgrid squeeze: True (default) passed to reshape before returning","title":"kamodofy"},{"location":"API/#pointlike","text":"kamodo.util. pointlike ( _func=None , signature=None , otypes=[ ] , squeeze=None ) Transforms a single-argument function to one that accepts m points of dimension n","title":"pointlike"},{"location":"API/#partial","text":"kamodo.util. partial ( _func=None , **partial_kwargs ) A partial function decorator Reduces function signature to reflect partially assigned kwargs","title":"partial"},{"location":"about/","text":"About Kamodo \u00b6 Kamodo has been under development at the Community Coordinated Modeling Center (CCMC), NASA GSFC since May, 2018. The CCMC supports the space weather community by providing software and services guided by domain experts in a variety of heliophysic science domains. Kamodo supports the goals of the CCMC by: Bringing together models and data into a single high-level mathematical framework Allows scientists and educators to work with complex space weather models and data with little or no coding experience Provides an easy-to-extend framework for developers. Kameleon legacy \u00b6 Kamodo shares some similarities with its predecessor, the CCMC's Kameleon Software Suite, insofaras it provides a unified API for space weather models. However, Kamodo gets there through a very different means: by leveraging cutting-edge python projects from both the heliophysics community (sunpy, spacepy, etc.) as well as more general mathematical frameworks like sympy. This allows Kamodo to be much more broad in its application, able to handle arbirtary scientific data and physics-based models. At the same time, by building on the tools provided by model and data providers, Kamodo inherits the high performance necessary for data analysis. We felt that due to the large departure in both design and scope from Kameleon, it was necessary to launch Kamodo as a separate project under a different moniker. Design philosophy \u00b6 Primary Design considerations Open Source (Apache 2.0) Should be format-, model-, data-agnostic Should support all types of users (non-coders, devs, modelers). Anyone can cook! Carrot approach to metadata (useful, but not mandatory)","title":"About"},{"location":"about/#about-kamodo","text":"Kamodo has been under development at the Community Coordinated Modeling Center (CCMC), NASA GSFC since May, 2018. The CCMC supports the space weather community by providing software and services guided by domain experts in a variety of heliophysic science domains. Kamodo supports the goals of the CCMC by: Bringing together models and data into a single high-level mathematical framework Allows scientists and educators to work with complex space weather models and data with little or no coding experience Provides an easy-to-extend framework for developers.","title":"About Kamodo"},{"location":"about/#kameleon-legacy","text":"Kamodo shares some similarities with its predecessor, the CCMC's Kameleon Software Suite, insofaras it provides a unified API for space weather models. However, Kamodo gets there through a very different means: by leveraging cutting-edge python projects from both the heliophysics community (sunpy, spacepy, etc.) as well as more general mathematical frameworks like sympy. This allows Kamodo to be much more broad in its application, able to handle arbirtary scientific data and physics-based models. At the same time, by building on the tools provided by model and data providers, Kamodo inherits the high performance necessary for data analysis. We felt that due to the large departure in both design and scope from Kameleon, it was necessary to launch Kamodo as a separate project under a different moniker.","title":"Kameleon legacy"},{"location":"about/#design-philosophy","text":"Primary Design considerations Open Source (Apache 2.0) Should be format-, model-, data-agnostic Should support all types of users (non-coders, devs, modelers). Anyone can cook! Carrot approach to metadata (useful, but not mandatory)","title":"Design philosophy"},{"location":"additional_resources/","text":"Additional Resources \u00b6 Examples of using Numpy f2py to compile Fortran code into importable Python modules: https://www.scivision.dev/f2py-running-fortran-code-in-python-on-windows/ https://github.com/scivision/f2py-examples Tutorial: Using Fortran from Python http://arogozhnikov.github.io/2015/11/29/using-fortran-from-python.html See Prototypes/Fortran2Python_example.ipynb for details Numpy documentation for f2py https://docs.scipy.org/doc/numpy/f2py/python-usage.html","title":"Additional Resources"},{"location":"additional_resources/#additional-resources","text":"Examples of using Numpy f2py to compile Fortran code into importable Python modules: https://www.scivision.dev/f2py-running-fortran-code-in-python-on-windows/ https://github.com/scivision/f2py-examples Tutorial: Using Fortran from Python http://arogozhnikov.github.io/2015/11/29/using-fortran-from-python.html See Prototypes/Fortran2Python_example.ipynb for details Numpy documentation for f2py https://docs.scipy.org/doc/numpy/f2py/python-usage.html","title":"Additional Resources"},{"location":"notebooks/CommandLineInterface/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Kamodo-CLI \u00b6 The kamodo command-line interface should be installed automatically with pip pip install kamodo Warning The command line app is a work in progress. Expect changes! Note You can run these examples in a notebook with !kamodo Run the command line interface with kamodo <key>.<subkey>=value instantiation \u00b6 To create a simple function ready for evaluation: kamodo model.params.f[cm]=x**2 lhs rhs symbol units f(x) f x**2 f(x) cm \\begin{equation}f{\\left(x \\right)} [cm] = x^{2}\\end{equation} Kamodo will print a description of the loaded model when verbose output is on (the default). evaluation \u00b6 To evaluate a model, provide arguments for each function. kamodo model.params.f[cm]=x**2 model.evaluate.f.x=[-3,-1,1,3] verbose=false f(x=[-3, -1, 1, 3]) cm = [9 1 1 9] visualization \u00b6 To visualize model output, provide plot parameters similar to evaluation kamodo model.params.f[cm]=x**2 model.plot.f.x.min=-2 model.plot.f.x.max=2 model.plot.f.x.n=25 verbose=False An interactive plot will open with your figure if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} window.PlotlyConfig = {MathJaxConfig: 'local'}; < script type = \"text/javascript\" > window . PLOTLYENV = window . PLOTLYENV || {} ; if ( document . getElementById ( \"5cbd8f8e-9d47-4bc3-a867-d4113a282fc6\" )) { Plotly . newPlot ( '5cbd8f8e-9d47-4bc3-a867-d4113a282fc6' , [ {\"name\": \"f[cm ] \", \" type \": \" scatter \", \" x \": [-2.0, -1.8333333333333333, -1.6666666666666667, -1.5, -1.3333333333333335, -1.1666666666666667, -1.0, -0.8333333333333335, -0.6666666666666667, -0.5, -0.3333333333333335, -0.16666666666666674, 0.0, 0.16666666666666652, 0.33333333333333304, 0.5, 0.6666666666666665, 0.833333333333333, 1.0, 1.1666666666666665, 1.333333333333333, 1.5, 1.6666666666666665, 1.833333333333333, 2.0], \" y \": [4.0, 3.3611111111111107, 2.777777777777778, 2.25, 1.7777777777777781, 1.3611111111111114, 1.0, 0.6944444444444446, 0.44444444444444453, 0.25, 0.11111111111111122, 0.027777777777777804, 0.0, 0.027777777777777728, 0.11111111111111091, 0.25, 0.44444444444444425, 0.694444444444444, 1.0, 1.3611111111111107, 1.777777777777777, 2.25, 2.7777777777777772, 3.36111111111111, 4.0]}], {\" autosize \": false, \" height \": 400, \" margin \": {\" b \": 32, \" pad \": 0, \" r \": 30, \" t \": 40}, \" template \": {\" data \": {\" bar \": [{\" error_x \": {\" color \": \" #2a3f5f \"}, \" error_y \": {\" color \": \" #2a3f5f \"}, \" marker \": {\" line \": {\" color \": \" #E5ECF6 \", \" width \": 0.5}}, \" type \": \" bar \"}], \" barpolar \": [{\" marker \": {\" line \": {\" color \": \" #E5ECF6 \", \" width \": 0.5}}, \" type \": \" barpolar \"}], \" carpet \": [{\" aaxis \": {\" endlinecolor \": \" #2a3f5f \", \" gridcolor \": \" white \", \" linecolor \": \" white \", \" minorgridcolor \": \" white \", \" startlinecolor \": \" #2a3f5f \"}, \" baxis \": {\" endlinecolor \": \" #2a3f5f \", \" gridcolor \": \" white \", \" linecolor \": \" white \", \" minorgridcolor \": \" white \", \" startlinecolor \": \" #2a3f5f \"}, \" type \": \" carpet \"}], \" choropleth \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" type \": \" choropleth \"}], \" contour \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" contour \"}], \" contourcarpet \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" type \": \" contourcarpet \"}], \" heatmap \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" heatmap \"}], \" heatmapgl \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" heatmapgl \"}], \" histogram \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" histogram \"}], \" histogram2d \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" histogram2d \"}], \" histogram2dcontour \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" histogram2dcontour \"}], \" mesh3d \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" type \": \" mesh3d \"}], \" parcoords \": [{\" line \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" parcoords \"}], \" pie \": [{\" automargin \": true, \" type \": \" pie \"}], \" scatter \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatter \"}], \" scatter3d \": [{\" line \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatter3d \"}], \" scattercarpet \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattercarpet \"}], \" scattergeo \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattergeo \"}], \" scattergl \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattergl \"}], \" scattermapbox \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattermapbox \"}], \" scatterpolar \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatterpolar \"}], \" scatterpolargl \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatterpolargl \"}], \" scatterternary \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatterternary \"}], \" surface \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" surface \"}], \" table \": [{\" cells \": {\" fill \": {\" color \": \" #EBF0F8 \"}, \" line \": {\" color \": \" white \"}}, \" header \": {\" fill \": {\" color \": \" #C8D4E3 \"}, \" line \": {\" color \": \" white \"}}, \" type \": \" table \"}]}, \" layout \": {\" annotationdefaults \": {\" arrowcolor \": \" #2a3f5f \", \" arrowhead \": 0, \" arrowwidth \": 1}, \" coloraxis \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" colorscale \": {\" diverging \": [[0, \" #8e0152 \"], [0.1, \" #c51b7d \"], [0.2, \" #de77ae \"], [0.3, \" #f1b6da \"], [0.4, \" #fde0ef \"], [0.5, \" #f7f7f7 \"], [0.6, \" #e6f5d0 \"], [0.7, \" #b8e186 \"], [0.8, \" #7fbc41 \"], [0.9, \" #4d9221 \"], [1, \" #276419 \"]], \" sequential \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" sequentialminus \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]]}, \" colorway \": [\" #636efa \", \" #EF553B \", \" #00cc96 \", \" #ab63fa \", \" #FFA15A \", \" #19d3f3 \", \" #FF6692 \", \" #B6E880 \", \" #FF97FF \", \" #FECB52 \"], \" font \": {\" color \": \" #2a3f5f \"}, \" geo \": {\" bgcolor \": \" white \", \" lakecolor \": \" white \", \" landcolor \": \" #E5ECF6 \", \" showlakes \": true, \" showland \": true, \" subunitcolor \": \" white \"}, \" hoverlabel \": {\" align \": \" left \"}, \" hovermode \": \" closest \", \" mapbox \": {\" style \": \" light \"}, \" paper_bgcolor \": \" white \", \" plot_bgcolor \": \" #E5ECF6 \", \" polar \": {\" angularaxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}, \" bgcolor \": \" #E5ECF6 \", \" radialaxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}}, \" scene \": {\" xaxis \": {\" backgroundcolor \": \" #E5ECF6 \", \" gridcolor \": \" white \", \" gridwidth \": 2, \" linecolor \": \" white \", \" showbackground \": true, \" ticks \": \"\", \" zerolinecolor \": \" white \"}, \" yaxis \": {\" backgroundcolor \": \" #E5ECF6 \", \" gridcolor \": \" white \", \" gridwidth \": 2, \" linecolor \": \" white \", \" showbackground \": true, \" ticks \": \"\", \" zerolinecolor \": \" white \"}, \" zaxis \": {\" backgroundcolor \": \" #E5ECF6 \", \" gridcolor \": \" white \", \" gridwidth \": 2, \" linecolor \": \" white \", \" showbackground \": true, \" ticks \": \"\", \" zerolinecolor \": \" white \"}}, \" shapedefaults \": {\" line \": {\" color \": \" #2a3f5f \"}}, \" ternary \": {\" aaxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}, \" baxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}, \" bgcolor \": \" #E5ECF6 \", \" caxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}}, \" title \": {\" x \": 0.05}, \" xaxis \": {\" automargin \": true, \" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\", \" title \": {\" standoff \": 15}, \" zerolinecolor \": \" white \", \" zerolinewidth \": 2}, \" yaxis \": {\" automargin \": true, \" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\", \" title \": {\" standoff \": 15}, \" zerolinecolor \": \" white \", \" zerolinewidth \": 2}}}, \" title \": {\" text \": \" $ f {\\\\ left ( x \\\\ right ) } [ cm ] = x ^ { 2 }$ \"}, \" width \": 700, \" xaxis \": {\" title \": {\" text \": \" $ x $ \"}}, \" yaxis \": {\" title \": {\" text \": \" $ f {\\\\ left ( x \\\\ right ) } [ cm ] $ \"}}}, {\" responsive \": true } ) } ; </ script > Kamodofied models \u00b6 To work with a kamodofied model, specify the model.class . kamodo model.class=kamodo.readers.tiegcm.TIEGCM_Kamodo model.params.filename=$PWD/s001.nc model.plot.EFLUX.lon=[0] Configuration \u00b6 Kamodo can use configuration files so that arguments do not have to be passed manually. To create your own configuration, create a config.yaml file in your project's directory: Running kamodo from a directory containing the above config.yaml will produce the same plot as before: ! kamodo lhs rhs symbol units f(x) f x**2 f(x) cm \\begin{equation}f{\\left(x \\right)} [cm] = x^{2}\\end{equation} Configuration Priority \u00b6 Kamodo is built on hydra, which prioritizes configuration using the following rules: If there are two configurations that define the same value, the second one would win. If two configurations are contributing to the same dictionary the result would be the combined dictionary. Help \u00b6 kamodo --help A low-coding command line interface for Kamodo This application allows users to work with kamodo-compatible models and data directly from the command line. Custom models, data, and expressions may be composed by editing config files without needing to write python. == Configuration groups == Compose your configuration from those groups (group=option) == Config == Override anything in the config (foo.bar=value) model: class: kamodo.Kamodo evaluate: {} fig_layout: {} params: {} plot: {} plot_conf: animation_opts: null auto_open: true auto_play: true config: null filename: temp-plot.html image: null image_filename: plot_image include_mathjax: cdn include_plotlyjs: true link_text: Export to plot.ly output_type: file show_link: false validate: true verbose: true Powered by Hydra (https://hydra.cc) Use --hydra-help to view Hydra specific help tab completion \u00b6 Kamodo supports tab completion for bash. To set up bash tab completion, run the following: eval \"$(kamodo -sc install=bash)\"","title":"CommandLine"},{"location":"notebooks/CommandLineInterface/#kamodo-cli","text":"The kamodo command-line interface should be installed automatically with pip pip install kamodo Warning The command line app is a work in progress. Expect changes! Note You can run these examples in a notebook with !kamodo Run the command line interface with kamodo <key>.<subkey>=value","title":"Kamodo-CLI"},{"location":"notebooks/CommandLineInterface/#instantiation","text":"To create a simple function ready for evaluation: kamodo model.params.f[cm]=x**2 lhs rhs symbol units f(x) f x**2 f(x) cm \\begin{equation}f{\\left(x \\right)} [cm] = x^{2}\\end{equation} Kamodo will print a description of the loaded model when verbose output is on (the default).","title":"instantiation"},{"location":"notebooks/CommandLineInterface/#evaluation","text":"To evaluate a model, provide arguments for each function. kamodo model.params.f[cm]=x**2 model.evaluate.f.x=[-3,-1,1,3] verbose=false f(x=[-3, -1, 1, 3]) cm = [9 1 1 9]","title":"evaluation"},{"location":"notebooks/CommandLineInterface/#visualization","text":"To visualize model output, provide plot parameters similar to evaluation kamodo model.params.f[cm]=x**2 model.plot.f.x.min=-2 model.plot.f.x.max=2 model.plot.f.x.n=25 verbose=False An interactive plot will open with your figure if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} window.PlotlyConfig = {MathJaxConfig: 'local'}; < script type = \"text/javascript\" > window . PLOTLYENV = window . PLOTLYENV || {} ; if ( document . getElementById ( \"5cbd8f8e-9d47-4bc3-a867-d4113a282fc6\" )) { Plotly . newPlot ( '5cbd8f8e-9d47-4bc3-a867-d4113a282fc6' , [ {\"name\": \"f[cm ] \", \" type \": \" scatter \", \" x \": [-2.0, -1.8333333333333333, -1.6666666666666667, -1.5, -1.3333333333333335, -1.1666666666666667, -1.0, -0.8333333333333335, -0.6666666666666667, -0.5, -0.3333333333333335, -0.16666666666666674, 0.0, 0.16666666666666652, 0.33333333333333304, 0.5, 0.6666666666666665, 0.833333333333333, 1.0, 1.1666666666666665, 1.333333333333333, 1.5, 1.6666666666666665, 1.833333333333333, 2.0], \" y \": [4.0, 3.3611111111111107, 2.777777777777778, 2.25, 1.7777777777777781, 1.3611111111111114, 1.0, 0.6944444444444446, 0.44444444444444453, 0.25, 0.11111111111111122, 0.027777777777777804, 0.0, 0.027777777777777728, 0.11111111111111091, 0.25, 0.44444444444444425, 0.694444444444444, 1.0, 1.3611111111111107, 1.777777777777777, 2.25, 2.7777777777777772, 3.36111111111111, 4.0]}], {\" autosize \": false, \" height \": 400, \" margin \": {\" b \": 32, \" pad \": 0, \" r \": 30, \" t \": 40}, \" template \": {\" data \": {\" bar \": [{\" error_x \": {\" color \": \" #2a3f5f \"}, \" error_y \": {\" color \": \" #2a3f5f \"}, \" marker \": {\" line \": {\" color \": \" #E5ECF6 \", \" width \": 0.5}}, \" type \": \" bar \"}], \" barpolar \": [{\" marker \": {\" line \": {\" color \": \" #E5ECF6 \", \" width \": 0.5}}, \" type \": \" barpolar \"}], \" carpet \": [{\" aaxis \": {\" endlinecolor \": \" #2a3f5f \", \" gridcolor \": \" white \", \" linecolor \": \" white \", \" minorgridcolor \": \" white \", \" startlinecolor \": \" #2a3f5f \"}, \" baxis \": {\" endlinecolor \": \" #2a3f5f \", \" gridcolor \": \" white \", \" linecolor \": \" white \", \" minorgridcolor \": \" white \", \" startlinecolor \": \" #2a3f5f \"}, \" type \": \" carpet \"}], \" choropleth \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" type \": \" choropleth \"}], \" contour \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" contour \"}], \" contourcarpet \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" type \": \" contourcarpet \"}], \" heatmap \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" heatmap \"}], \" heatmapgl \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" heatmapgl \"}], \" histogram \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" histogram \"}], \" histogram2d \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" histogram2d \"}], \" histogram2dcontour \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" histogram2dcontour \"}], \" mesh3d \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" type \": \" mesh3d \"}], \" parcoords \": [{\" line \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" parcoords \"}], \" pie \": [{\" automargin \": true, \" type \": \" pie \"}], \" scatter \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatter \"}], \" scatter3d \": [{\" line \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatter3d \"}], \" scattercarpet \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattercarpet \"}], \" scattergeo \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattergeo \"}], \" scattergl \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattergl \"}], \" scattermapbox \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scattermapbox \"}], \" scatterpolar \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatterpolar \"}], \" scatterpolargl \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatterpolargl \"}], \" scatterternary \": [{\" marker \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" type \": \" scatterternary \"}], \" surface \": [{\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}, \" colorscale \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" type \": \" surface \"}], \" table \": [{\" cells \": {\" fill \": {\" color \": \" #EBF0F8 \"}, \" line \": {\" color \": \" white \"}}, \" header \": {\" fill \": {\" color \": \" #C8D4E3 \"}, \" line \": {\" color \": \" white \"}}, \" type \": \" table \"}]}, \" layout \": {\" annotationdefaults \": {\" arrowcolor \": \" #2a3f5f \", \" arrowhead \": 0, \" arrowwidth \": 1}, \" coloraxis \": {\" colorbar \": {\" outlinewidth \": 0, \" ticks \": \"\"}}, \" colorscale \": {\" diverging \": [[0, \" #8e0152 \"], [0.1, \" #c51b7d \"], [0.2, \" #de77ae \"], [0.3, \" #f1b6da \"], [0.4, \" #fde0ef \"], [0.5, \" #f7f7f7 \"], [0.6, \" #e6f5d0 \"], [0.7, \" #b8e186 \"], [0.8, \" #7fbc41 \"], [0.9, \" #4d9221 \"], [1, \" #276419 \"]], \" sequential \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]], \" sequentialminus \": [[0.0, \" #0d0887 \"], [0.1111111111111111, \" #46039f \"], [0.2222222222222222, \" #7201a8 \"], [0.3333333333333333, \" #9c179e \"], [0.4444444444444444, \" #bd3786 \"], [0.5555555555555556, \" #d8576b \"], [0.6666666666666666, \" #ed7953 \"], [0.7777777777777778, \" #fb9f3a \"], [0.8888888888888888, \" #fdca26 \"], [1.0, \" #f0f921 \"]]}, \" colorway \": [\" #636efa \", \" #EF553B \", \" #00cc96 \", \" #ab63fa \", \" #FFA15A \", \" #19d3f3 \", \" #FF6692 \", \" #B6E880 \", \" #FF97FF \", \" #FECB52 \"], \" font \": {\" color \": \" #2a3f5f \"}, \" geo \": {\" bgcolor \": \" white \", \" lakecolor \": \" white \", \" landcolor \": \" #E5ECF6 \", \" showlakes \": true, \" showland \": true, \" subunitcolor \": \" white \"}, \" hoverlabel \": {\" align \": \" left \"}, \" hovermode \": \" closest \", \" mapbox \": {\" style \": \" light \"}, \" paper_bgcolor \": \" white \", \" plot_bgcolor \": \" #E5ECF6 \", \" polar \": {\" angularaxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}, \" bgcolor \": \" #E5ECF6 \", \" radialaxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}}, \" scene \": {\" xaxis \": {\" backgroundcolor \": \" #E5ECF6 \", \" gridcolor \": \" white \", \" gridwidth \": 2, \" linecolor \": \" white \", \" showbackground \": true, \" ticks \": \"\", \" zerolinecolor \": \" white \"}, \" yaxis \": {\" backgroundcolor \": \" #E5ECF6 \", \" gridcolor \": \" white \", \" gridwidth \": 2, \" linecolor \": \" white \", \" showbackground \": true, \" ticks \": \"\", \" zerolinecolor \": \" white \"}, \" zaxis \": {\" backgroundcolor \": \" #E5ECF6 \", \" gridcolor \": \" white \", \" gridwidth \": 2, \" linecolor \": \" white \", \" showbackground \": true, \" ticks \": \"\", \" zerolinecolor \": \" white \"}}, \" shapedefaults \": {\" line \": {\" color \": \" #2a3f5f \"}}, \" ternary \": {\" aaxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}, \" baxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}, \" bgcolor \": \" #E5ECF6 \", \" caxis \": {\" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\"}}, \" title \": {\" x \": 0.05}, \" xaxis \": {\" automargin \": true, \" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\", \" title \": {\" standoff \": 15}, \" zerolinecolor \": \" white \", \" zerolinewidth \": 2}, \" yaxis \": {\" automargin \": true, \" gridcolor \": \" white \", \" linecolor \": \" white \", \" ticks \": \"\", \" title \": {\" standoff \": 15}, \" zerolinecolor \": \" white \", \" zerolinewidth \": 2}}}, \" title \": {\" text \": \" $ f {\\\\ left ( x \\\\ right ) } [ cm ] = x ^ { 2 }$ \"}, \" width \": 700, \" xaxis \": {\" title \": {\" text \": \" $ x $ \"}}, \" yaxis \": {\" title \": {\" text \": \" $ f {\\\\ left ( x \\\\ right ) } [ cm ] $ \"}}}, {\" responsive \": true } ) } ; </ script >","title":"visualization"},{"location":"notebooks/CommandLineInterface/#kamodofied-models","text":"To work with a kamodofied model, specify the model.class . kamodo model.class=kamodo.readers.tiegcm.TIEGCM_Kamodo model.params.filename=$PWD/s001.nc model.plot.EFLUX.lon=[0]","title":"Kamodofied models"},{"location":"notebooks/CommandLineInterface/#configuration","text":"Kamodo can use configuration files so that arguments do not have to be passed manually. To create your own configuration, create a config.yaml file in your project's directory: Running kamodo from a directory containing the above config.yaml will produce the same plot as before: ! kamodo lhs rhs symbol units f(x) f x**2 f(x) cm \\begin{equation}f{\\left(x \\right)} [cm] = x^{2}\\end{equation}","title":"Configuration"},{"location":"notebooks/CommandLineInterface/#configuration-priority","text":"Kamodo is built on hydra, which prioritizes configuration using the following rules: If there are two configurations that define the same value, the second one would win. If two configurations are contributing to the same dictionary the result would be the combined dictionary.","title":"Configuration Priority"},{"location":"notebooks/CommandLineInterface/#help","text":"kamodo --help A low-coding command line interface for Kamodo This application allows users to work with kamodo-compatible models and data directly from the command line. Custom models, data, and expressions may be composed by editing config files without needing to write python. == Configuration groups == Compose your configuration from those groups (group=option) == Config == Override anything in the config (foo.bar=value) model: class: kamodo.Kamodo evaluate: {} fig_layout: {} params: {} plot: {} plot_conf: animation_opts: null auto_open: true auto_play: true config: null filename: temp-plot.html image: null image_filename: plot_image include_mathjax: cdn include_plotlyjs: true link_text: Export to plot.ly output_type: file show_link: false validate: true verbose: true Powered by Hydra (https://hydra.cc) Use --hydra-help to view Hydra specific help","title":"Help"},{"location":"notebooks/CommandLineInterface/#tab-completion","text":"Kamodo supports tab completion for bash. To set up bash tab completion, run the following: eval \"$(kamodo -sc install=bash)\"","title":"tab completion"},{"location":"notebooks/FieldIntegration/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Field Integration Techniques \u00b6 Many analysis techniques for vector fields require solving an initial value problem for an arbitrary set of seed points and evaluating such solutions at a chosen resolution. Kamodo makes it easy to generate fieldline solutions by providing a function decorator that wraps scipy's powerful solve_ivp function. Each family of solutions is represented by a single function of a complex parameter. We illustrate the flexibility of this approach in the example below. # initialize from plotly.offline import iplot , plot , init_notebook_mode # init_notebook_mode(connected = True) from kamodo import Kamodo , event , pointlike , kamodofy , solve import numpy as np import pandas as pd Dipole field model \u00b6 We use the following dipole field model that can accept (m,) and (1,m), and (n,m) arrays. def Bdip ( rvec ): \"\"\"Need math to work in a variety of arg shapes\"\"\" muvec = Bdip . muvec r = np . linalg . norm ( rvec , axis = 1 ) r [ r == 0 ] = np . nan try : rhat = rvec / r except : rhat = ( rvec . T / r ) . T try : result = 3 * np . dot ( rhat , muvec . T ) except : result = 3 * np . dot ( rhat . T , muvec . T ) . T result = ( rhat . T * result ) . T try : result = result - muvec except : result = ( result - muvec . T ) . T try : result = result / r ** 3 except : result = ( result . T / r ** 3 ) . T return result # set dipole moment Bdip . muvec = np . array ([ 0 , 0 , - 1 ]) # pointlike enforces dimensionality Bdip = pointlike ( Bdip , '(n,m)->(n,m)' , [ np . float ], squeeze = 0 ) kamodo = Kamodo () kamodo [ 'Bvec' ] = Bdip # register the dipole field kamodo Normalization \u00b6 Instead of solving the initial value problem on the original field, we will be solving on the normalized field. This will mean that the integral path is the same as the arclength, allowing us to control the visual fidelity of the resulting field. Create a normalization function to be applied to our field @kamodofy ( equation = \"$$ \\\\ hat {n} ( \\\\ vec {y} ) = \\\\ vec {y} / \\\\ sqrt{ \\\\ vec {y} \\\\ cdot \\\\ vec {y} } $$\" ) @pointlike ( signature = '(m,n)->(m,n)' , squeeze = 0 ) def normalized ( yvec ): r = np . linalg . norm ( yvec , axis = 1 ) r [ r == 0 ] = np . nan try : return yvec / r except : return ( yvec . T / r ) . T kamodo [ 'nhat' ] = normalized Create a normalized field kamodo [ 'bhat' ] = \"nhat(Bvec)\" kamodo Solving the initial value problem \u00b6 Generate a set of seed points for integration x0 = np . linspace ( - np . pi , np . pi , 6 ) y0 = np . linspace ( - np . pi , np . pi , 6 ) z0 = 1 seeds = np . array ( np . column_stack ([ c . ravel () for c in np . meshgrid ( x0 , y0 , z0 )])) Create a stopping boundary for field line integrator @event def boundary ( s , rvec ): r = np . linalg . norm ( rvec ) if np . isnan ( r ): result = 0 else : result = r - 1 return result Solve the initial value problem for the normalized field kamodo [ 'svec' ] = solve ( kamodo . bhat , # the field to be solved seeds , # the initial positions 's' , # the name of the integration parameter ( 0 , 30 ), # the span to integrate over npoints = 60 , # the number of points to evaluate the solution events = boundary , # stop at the boundary ) kamodo The solver returns a family of solutions, represented as a single function of a complex array, \\vec{s}(s) where s is a complex array. Evaluating the Solutions \u00b6 On evaluation, \\vec{s}(s) returns a pandas dataframe. kamodo . svec () . head () When using the default argument above, the solution evaluates at a resolution of npoints/span, stopping at the boundary. Complex parameterization \u00b6 Kamodo represents the family of solutions to the initial value problem as a single function of a complex array. The floor of the real part of the input parameter corresponds to the original seed array: kamodo . svec ([ 0 , 1 , 2 ]) . values compare with original seeds: seeds [[ 0 , 1 , 2 ]] The imaginary part denotes the integral along the corresponding solution. Here, we can choose evaluation points that were not in the original solution. Parameters outside the original span will be extrapolated. kamodo . svec ([ - 6 j , - 5 j , 0 , 5 j , 6 j , 4 + 4 j , 4 - 5.777 j ]) Plotting Fieldlines \u00b6 We can quickly generate plots for all fieldlines at the default resolution by calling plot with the name of the fieldlines solution. import plotly.io as pio fig = kamodo . plot ( 'svec' ) pio . write_image ( fig , './images/fieldlines.svg' ) To show the direction of the field at each point, we can evaluate \\hat{B}(\\vec{s}(s)) fig = kamodo . plot ( 'svec' , bhat = dict ( rvec = kamodo . svec ())) pio . write_image ( fig , './images/fieldlines_vectors.svg' ) Integration totals \u00b6 To compute the total integral for each fieldline individually, we need a function to subtract the integration results at the endpoints. def integral ( fieldline ): endpoints = fieldline . reset_index () . integral . iloc [[ 0 , - 1 ]] return endpoints . values [ - 1 ] - endpoints . values [ 0 ] totals = [] for seed , fieldline in kamodo . svec () . groupby ( level = 'seed' ): totals . append ( integral ( fieldline )) totals [: 5 ] Alternatively, we can use pandas' aggregation methods to apply our function on each fieldline. kamodo . svec () . groupby ( level = 'seed' ) . aggregate ( integral )","title":"Field Integration"},{"location":"notebooks/FieldIntegration/#field-integration-techniques","text":"Many analysis techniques for vector fields require solving an initial value problem for an arbitrary set of seed points and evaluating such solutions at a chosen resolution. Kamodo makes it easy to generate fieldline solutions by providing a function decorator that wraps scipy's powerful solve_ivp function. Each family of solutions is represented by a single function of a complex parameter. We illustrate the flexibility of this approach in the example below. # initialize from plotly.offline import iplot , plot , init_notebook_mode # init_notebook_mode(connected = True) from kamodo import Kamodo , event , pointlike , kamodofy , solve import numpy as np import pandas as pd","title":"Field Integration Techniques"},{"location":"notebooks/FieldIntegration/#dipole-field-model","text":"We use the following dipole field model that can accept (m,) and (1,m), and (n,m) arrays. def Bdip ( rvec ): \"\"\"Need math to work in a variety of arg shapes\"\"\" muvec = Bdip . muvec r = np . linalg . norm ( rvec , axis = 1 ) r [ r == 0 ] = np . nan try : rhat = rvec / r except : rhat = ( rvec . T / r ) . T try : result = 3 * np . dot ( rhat , muvec . T ) except : result = 3 * np . dot ( rhat . T , muvec . T ) . T result = ( rhat . T * result ) . T try : result = result - muvec except : result = ( result - muvec . T ) . T try : result = result / r ** 3 except : result = ( result . T / r ** 3 ) . T return result # set dipole moment Bdip . muvec = np . array ([ 0 , 0 , - 1 ]) # pointlike enforces dimensionality Bdip = pointlike ( Bdip , '(n,m)->(n,m)' , [ np . float ], squeeze = 0 ) kamodo = Kamodo () kamodo [ 'Bvec' ] = Bdip # register the dipole field kamodo","title":"Dipole field model"},{"location":"notebooks/FieldIntegration/#normalization","text":"Instead of solving the initial value problem on the original field, we will be solving on the normalized field. This will mean that the integral path is the same as the arclength, allowing us to control the visual fidelity of the resulting field. Create a normalization function to be applied to our field @kamodofy ( equation = \"$$ \\\\ hat {n} ( \\\\ vec {y} ) = \\\\ vec {y} / \\\\ sqrt{ \\\\ vec {y} \\\\ cdot \\\\ vec {y} } $$\" ) @pointlike ( signature = '(m,n)->(m,n)' , squeeze = 0 ) def normalized ( yvec ): r = np . linalg . norm ( yvec , axis = 1 ) r [ r == 0 ] = np . nan try : return yvec / r except : return ( yvec . T / r ) . T kamodo [ 'nhat' ] = normalized Create a normalized field kamodo [ 'bhat' ] = \"nhat(Bvec)\" kamodo","title":"Normalization"},{"location":"notebooks/FieldIntegration/#solving-the-initial-value-problem","text":"Generate a set of seed points for integration x0 = np . linspace ( - np . pi , np . pi , 6 ) y0 = np . linspace ( - np . pi , np . pi , 6 ) z0 = 1 seeds = np . array ( np . column_stack ([ c . ravel () for c in np . meshgrid ( x0 , y0 , z0 )])) Create a stopping boundary for field line integrator @event def boundary ( s , rvec ): r = np . linalg . norm ( rvec ) if np . isnan ( r ): result = 0 else : result = r - 1 return result Solve the initial value problem for the normalized field kamodo [ 'svec' ] = solve ( kamodo . bhat , # the field to be solved seeds , # the initial positions 's' , # the name of the integration parameter ( 0 , 30 ), # the span to integrate over npoints = 60 , # the number of points to evaluate the solution events = boundary , # stop at the boundary ) kamodo The solver returns a family of solutions, represented as a single function of a complex array, \\vec{s}(s) where s is a complex array.","title":"Solving the initial value problem"},{"location":"notebooks/FieldIntegration/#evaluating-the-solutions","text":"On evaluation, \\vec{s}(s) returns a pandas dataframe. kamodo . svec () . head () When using the default argument above, the solution evaluates at a resolution of npoints/span, stopping at the boundary.","title":"Evaluating the Solutions"},{"location":"notebooks/FieldIntegration/#complex-parameterization","text":"Kamodo represents the family of solutions to the initial value problem as a single function of a complex array. The floor of the real part of the input parameter corresponds to the original seed array: kamodo . svec ([ 0 , 1 , 2 ]) . values compare with original seeds: seeds [[ 0 , 1 , 2 ]] The imaginary part denotes the integral along the corresponding solution. Here, we can choose evaluation points that were not in the original solution. Parameters outside the original span will be extrapolated. kamodo . svec ([ - 6 j , - 5 j , 0 , 5 j , 6 j , 4 + 4 j , 4 - 5.777 j ])","title":"Complex parameterization"},{"location":"notebooks/FieldIntegration/#plotting-fieldlines","text":"We can quickly generate plots for all fieldlines at the default resolution by calling plot with the name of the fieldlines solution. import plotly.io as pio fig = kamodo . plot ( 'svec' ) pio . write_image ( fig , './images/fieldlines.svg' ) To show the direction of the field at each point, we can evaluate \\hat{B}(\\vec{s}(s)) fig = kamodo . plot ( 'svec' , bhat = dict ( rvec = kamodo . svec ())) pio . write_image ( fig , './images/fieldlines_vectors.svg' )","title":"Plotting Fieldlines"},{"location":"notebooks/FieldIntegration/#integration-totals","text":"To compute the total integral for each fieldline individually, we need a function to subtract the integration results at the endpoints. def integral ( fieldline ): endpoints = fieldline . reset_index () . integral . iloc [[ 0 , - 1 ]] return endpoints . values [ - 1 ] - endpoints . values [ 0 ] totals = [] for seed , fieldline in kamodo . svec () . groupby ( level = 'seed' ): totals . append ( integral ( fieldline )) totals [: 5 ] Alternatively, we can use pandas' aggregation methods to apply our function on each fieldline. kamodo . svec () . groupby ( level = 'seed' ) . aggregate ( integral )","title":"Integration totals"},{"location":"notebooks/Home/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Kamodo Project Page \u00b6 Kamodo is a new CCMC tool for access, interpolation, and visualization of space weather models and data in python. Kamodo allows model developers to represent simulation results as mathematical functions which may be manipulated directly by end users. Kamodo handles unit conversion transparently and supports interactive science discovery through jupyter notebooks with minimal coding and is accessible through python and fortran. Usage \u00b6 Suppose we have a vector field defined by a function of positions in the x-y plane: from kamodo import kamodofy import numpy as np x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) @kamodofy ( units = 'km/s' ) def fvec ( rvec = points ): ux = np . sin ( rvec [:, 0 ]) uy = np . cos ( rvec [:, 1 ]) return np . vstack (( ux , uy )) . T The @kamodofy decorator lets us register this field with units to enable unit-conversion downstream: from kamodo import Kamodo kamodo = Kamodo ( fvec = fvec ) kamodo \\begin{equation}\\vec{f}{\\left(\\vec{r} \\right)} [km/s] = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} kamodo . to_latex () '\\\\begin{equation}\\\\vec{f}{\\\\left(\\\\vec{r} \\\\right)} [km/s] = \\\\lambda{\\\\left(\\\\vec{r} \\\\right)}\\\\end{equation}' We can now evaluate our function using dot notation: kamodo . fvec ( np . array ([[ - 1 , 1 ]])) array([[-0.84147098, 0.54030231]]) We can perform unit conversion: kamodo [ 'gvec[m/s]' ] = 'fvec' kamodo \\begin{equation}\\vec{f}{\\left(\\vec{r} \\right)} [km/s] = \\lambda{\\left(\\vec{r} \\right)}\\end{equation}\\begin{equation}\\vec{g}{\\left(\\vec{r} \\right)} [m/s] = 1000 \\vec{f}{\\left(\\vec{r} \\right)}\\end{equation} kamodo . gvec ( np . array ([[ - 1 , 1 ]])) array([[-841.47098481, 540.30230587]]) We can even generate plots. import plotly.io as pio fig = kamodo . plot ( 'fvec' ) pio . write_image ( fig , 'images/fig2d-usage.svg' ) Getting started \u00b6 Where to download \u00b6 If you have a nasa.developer.gov account, you may access the kamodo repository with git : git pull https://developer.nasa.gov/CCMC/Kameleon2.0 Note Kamodo is currently only available to users with NASA credentials. We are in the process of making Kamodo open to the public as an open-source project. Download (mini)conda \u00b6 We strongly recommend using the conda environment system to avoid library conflicts with your host machine's python. Download and install miniconda from here . Create Kamodo environment \u00b6 Create a new environment for kamodo conda create -n kamodo python=2.7 jupyter pandas numpy Activate new environment \u00b6 From a bash shell: source activate kamodo Requirements numpy scipy sympy pandas plotly==3.3 pytest psutil Loading a notebook \u00b6 Start the notebook server in the Prototypes subdirectory jupyter notebook Prototypes","title":"Home"},{"location":"notebooks/Home/#kamodo-project-page","text":"Kamodo is a new CCMC tool for access, interpolation, and visualization of space weather models and data in python. Kamodo allows model developers to represent simulation results as mathematical functions which may be manipulated directly by end users. Kamodo handles unit conversion transparently and supports interactive science discovery through jupyter notebooks with minimal coding and is accessible through python and fortran.","title":"Kamodo Project Page"},{"location":"notebooks/Home/#usage","text":"Suppose we have a vector field defined by a function of positions in the x-y plane: from kamodo import kamodofy import numpy as np x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) @kamodofy ( units = 'km/s' ) def fvec ( rvec = points ): ux = np . sin ( rvec [:, 0 ]) uy = np . cos ( rvec [:, 1 ]) return np . vstack (( ux , uy )) . T The @kamodofy decorator lets us register this field with units to enable unit-conversion downstream: from kamodo import Kamodo kamodo = Kamodo ( fvec = fvec ) kamodo \\begin{equation}\\vec{f}{\\left(\\vec{r} \\right)} [km/s] = \\lambda{\\left(\\vec{r} \\right)}\\end{equation} kamodo . to_latex () '\\\\begin{equation}\\\\vec{f}{\\\\left(\\\\vec{r} \\\\right)} [km/s] = \\\\lambda{\\\\left(\\\\vec{r} \\\\right)}\\\\end{equation}' We can now evaluate our function using dot notation: kamodo . fvec ( np . array ([[ - 1 , 1 ]])) array([[-0.84147098, 0.54030231]]) We can perform unit conversion: kamodo [ 'gvec[m/s]' ] = 'fvec' kamodo \\begin{equation}\\vec{f}{\\left(\\vec{r} \\right)} [km/s] = \\lambda{\\left(\\vec{r} \\right)}\\end{equation}\\begin{equation}\\vec{g}{\\left(\\vec{r} \\right)} [m/s] = 1000 \\vec{f}{\\left(\\vec{r} \\right)}\\end{equation} kamodo . gvec ( np . array ([[ - 1 , 1 ]])) array([[-841.47098481, 540.30230587]]) We can even generate plots. import plotly.io as pio fig = kamodo . plot ( 'fvec' ) pio . write_image ( fig , 'images/fig2d-usage.svg' )","title":"Usage"},{"location":"notebooks/Home/#getting-started","text":"","title":"Getting started"},{"location":"notebooks/Home/#where-to-download","text":"If you have a nasa.developer.gov account, you may access the kamodo repository with git : git pull https://developer.nasa.gov/CCMC/Kameleon2.0 Note Kamodo is currently only available to users with NASA credentials. We are in the process of making Kamodo open to the public as an open-source project.","title":"Where to download"},{"location":"notebooks/Home/#download-miniconda","text":"We strongly recommend using the conda environment system to avoid library conflicts with your host machine's python. Download and install miniconda from here .","title":"Download (mini)conda"},{"location":"notebooks/Home/#create-kamodo-environment","text":"Create a new environment for kamodo conda create -n kamodo python=2.7 jupyter pandas numpy","title":"Create Kamodo environment"},{"location":"notebooks/Home/#activate-new-environment","text":"From a bash shell: source activate kamodo Requirements numpy scipy sympy pandas plotly==3.3 pytest psutil","title":"Activate new environment"},{"location":"notebooks/Home/#loading-a-notebook","text":"Start the notebook server in the Prototypes subdirectory jupyter notebook Prototypes","title":"Loading a notebook"},{"location":"notebooks/Kamodo/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Overview \u00b6 Kamodo provides a functional interface for space weather analysis, visualization, and knowledge discovery, allowing many problems in scientific data analysis to be posed in terms of function composition and evaluation. We'll walk through its general features here. Kamodo objects \u00b6 Users primarily interact with models and data through Kamodo objects. from kamodo import Kamodo Function registration \u00b6 Kamodo objects are essentially python dictionaries storing variable symbols as keys and their interpolating functions as values. New functions may be registered either at the initialization of the Kamodo object or later using dictionary bracket syntax. kamodo = Kamodo ( f = 'x**2' ) kamodo kamodo . f ( 3 ) kamodo = Kamodo ( '$x = t^2$' ) kamodo [ 'g' ] = 'y-1' kamodo kamodo . g ( 3 ) Function composition \u00b6 Kamodo automatically composes functions through specifying on the right-hand-side. kamodo [ 'f' ] = 'g(x)' kamodo Here we have defined two functions x(t) , g(y) , and the composition g\u2218f . Kamodo was able to determine that f is implicitly a function of t even though we did not say so in f 's declaration. Function evaluation \u00b6 Kamodo uses sympy's lambdify function to turn the above equations into highly optimized functions for numerical evaluation. We may evaluate f(t) for t=3 using \"dot\" notation: kamodo . f ( 3 ) help ( kamodo . g ) where the return type is a numpy array. We could also have passed in a numpy array and the result shares the same shape: import numpy as np t = np . linspace ( - 5 , 5 , 100000 ) result = kamodo . f ( t ) assert ( t . shape == result . shape ) Unit conversion \u00b6 Kamodo automatically handles unit conversions. Simply declare units on the left-hand-side of expressions using bracket notation. kamodo = Kamodo ( 'mass[kg] = x' , 'vol[m^3] = y' ) kamodo Unless specified, Kamodo will assign the units for newly defined variables: kamodo [ 'rho' ] = 'mass/vol' kamodo We may override the default behavior by simply naming the our chosen units in the left hand side. kamodo [ 'rho(x,y)[g/cm^3]' ] = 'mass/vol' kamodo Note Kamodo will raise an error if the left and right-hand-side units are incompatible. Even though generated functions are unitless, the units are clearly displayed on the lhs. We think this is a good trade-off between performance and legibility. kamodo . detail () kamodo . rho ( 3 , 4 ) We can verify that kamodo produces the correct output upon evaluation. assert ( kamodo . rho ( 3 , 8 ) == ( 3 * 1000. ) / ( 8 * 100 ** 3 )) Variable naming conventions \u00b6 Kamodo allows for a wide array of variable names to suite your problem space, including greek, subscripts, superscripts. kamodo = Kamodo ( 'rho = ALPHA+BETA+GAMMA' , 'rvec = t' , 'fprime = x' , 'xvec_i = xvec_iminus1 + 1' , 'F__gravity = G*M*m/R**2' , ) kamodo def rho ( x ): pass Kamodo ( rho = rho ) For more details on variable names, see the Syntax section. Kamodofication \u00b6 Many functions can not be written as simple mathematical expressions - they could represent simulation output or observational data. For this reason, we provide a @kamodofy decorator, which turns any callable function into a kamodo-compatible variable and adds metadata that enables unit conversion. from kamodo import kamodofy , Kamodo import numpy as np @kamodofy ( units = 'kg/m**3' , citation = 'Bob et. al, 2018' ) def rho ( x = np . array ([ 3 , 4 , 5 ]), y = np . array ([ 1 , 2 , 3 ])): \"\"\"A function that computes density\"\"\" return x + y kamodo = Kamodo ( rho = rho ) kamodo [ 'den[g/cm^3]' ] = 'rho' kamodo kamodo . den ( 3 , 4 ) kamodo . rho . meta # PyHC standard kamodo . rho () kamodo . rho . data # PyHC standard Original function doc strings and signatures passed through help ( kamodo . rho ) kamodo . detail () Visualization \u00b6 Kamodo graphs are generated directly from function signatures by examining the structure of both output and input arguments. from plotting import plot_types plot_types Kamodo uses plotly for visualization, enabling a rich array of interactive graphs and easy web deployment. import plotly.io as pio from plotly.offline import iplot , plot , init_notebook_mode init_notebook_mode ( connected = True ) @kamodofy ( units = 'kg/m^3' ) def rho ( x = np . linspace ( 0 , 1 , 20 ), y = np . linspace ( - 1 , 1 , 40 )): \"\"\"A function that computes density\"\"\" x_ , y_ = np . meshgrid ( x , y ) return x_ * y_ kamodo = Kamodo ( rho = rho ) kamodo We will generate an image of this function using plotly fig = kamodo . plot ( 'rho' ) # pio.write_image(fig, 'images/Kamodo_fig1.svg') See the Visualization section for detailed examples. Latex I/O \u00b6 Even though math is the language of physics, most scientific analysis software requires you to learn new programing languages. Kamodo allows users to write their mathematical expressions in LaTeX, a typesetting language most scientists already know: kamodo = Kamodo ( '$rho[kg/m^3] = x^3$' , '$v[cm/s] = y^2$' ) kamodo [ 'p[Pa]' ] = '$ \\\\ rho v^2$' kamodo The resulting equation set may also be exported as a LaTeX string for use in publications: print ( kamodo . to_latex () + ' \\n .' ) Simulation api \u00b6 Kamodo offers a simple api for functions composed of each other. Define variables as usual (order matters). kamodo = Kamodo () kamodo [ 'y_iplus1' ] = 'x_i + 1' kamodo [ 'x_iplus1' ] = 'y_i - 2' kamodo Now add the update attribute to map functions onto arguments. kamodo . x_iplus1 . update = 'x_i' kamodo . y_iplus1 . update = 'y_i' Create a simulation with initial conditions simulation = kamodo . simulate ( x_i = 0 , steps = 5 ) simulation #an iterator of arg, val dictionaries Run the simulation by iterating through the generator. import pandas as pd pd . DataFrame ( simulation ) # pandas conveniently iterates the results for display","title":"Introduction"},{"location":"notebooks/Kamodo/#overview","text":"Kamodo provides a functional interface for space weather analysis, visualization, and knowledge discovery, allowing many problems in scientific data analysis to be posed in terms of function composition and evaluation. We'll walk through its general features here.","title":"Overview"},{"location":"notebooks/Kamodo/#kamodo-objects","text":"Users primarily interact with models and data through Kamodo objects. from kamodo import Kamodo","title":"Kamodo objects"},{"location":"notebooks/Kamodo/#function-registration","text":"Kamodo objects are essentially python dictionaries storing variable symbols as keys and their interpolating functions as values. New functions may be registered either at the initialization of the Kamodo object or later using dictionary bracket syntax. kamodo = Kamodo ( f = 'x**2' ) kamodo kamodo . f ( 3 ) kamodo = Kamodo ( '$x = t^2$' ) kamodo [ 'g' ] = 'y-1' kamodo kamodo . g ( 3 )","title":"Function registration"},{"location":"notebooks/Kamodo/#function-composition","text":"Kamodo automatically composes functions through specifying on the right-hand-side. kamodo [ 'f' ] = 'g(x)' kamodo Here we have defined two functions x(t) , g(y) , and the composition g\u2218f . Kamodo was able to determine that f is implicitly a function of t even though we did not say so in f 's declaration.","title":"Function composition"},{"location":"notebooks/Kamodo/#function-evaluation","text":"Kamodo uses sympy's lambdify function to turn the above equations into highly optimized functions for numerical evaluation. We may evaluate f(t) for t=3 using \"dot\" notation: kamodo . f ( 3 ) help ( kamodo . g ) where the return type is a numpy array. We could also have passed in a numpy array and the result shares the same shape: import numpy as np t = np . linspace ( - 5 , 5 , 100000 ) result = kamodo . f ( t ) assert ( t . shape == result . shape )","title":"Function evaluation"},{"location":"notebooks/Kamodo/#unit-conversion","text":"Kamodo automatically handles unit conversions. Simply declare units on the left-hand-side of expressions using bracket notation. kamodo = Kamodo ( 'mass[kg] = x' , 'vol[m^3] = y' ) kamodo Unless specified, Kamodo will assign the units for newly defined variables: kamodo [ 'rho' ] = 'mass/vol' kamodo We may override the default behavior by simply naming the our chosen units in the left hand side. kamodo [ 'rho(x,y)[g/cm^3]' ] = 'mass/vol' kamodo Note Kamodo will raise an error if the left and right-hand-side units are incompatible. Even though generated functions are unitless, the units are clearly displayed on the lhs. We think this is a good trade-off between performance and legibility. kamodo . detail () kamodo . rho ( 3 , 4 ) We can verify that kamodo produces the correct output upon evaluation. assert ( kamodo . rho ( 3 , 8 ) == ( 3 * 1000. ) / ( 8 * 100 ** 3 ))","title":"Unit conversion"},{"location":"notebooks/Kamodo/#variable-naming-conventions","text":"Kamodo allows for a wide array of variable names to suite your problem space, including greek, subscripts, superscripts. kamodo = Kamodo ( 'rho = ALPHA+BETA+GAMMA' , 'rvec = t' , 'fprime = x' , 'xvec_i = xvec_iminus1 + 1' , 'F__gravity = G*M*m/R**2' , ) kamodo def rho ( x ): pass Kamodo ( rho = rho ) For more details on variable names, see the Syntax section.","title":"Variable naming conventions"},{"location":"notebooks/Kamodo/#kamodofication","text":"Many functions can not be written as simple mathematical expressions - they could represent simulation output or observational data. For this reason, we provide a @kamodofy decorator, which turns any callable function into a kamodo-compatible variable and adds metadata that enables unit conversion. from kamodo import kamodofy , Kamodo import numpy as np @kamodofy ( units = 'kg/m**3' , citation = 'Bob et. al, 2018' ) def rho ( x = np . array ([ 3 , 4 , 5 ]), y = np . array ([ 1 , 2 , 3 ])): \"\"\"A function that computes density\"\"\" return x + y kamodo = Kamodo ( rho = rho ) kamodo [ 'den[g/cm^3]' ] = 'rho' kamodo kamodo . den ( 3 , 4 ) kamodo . rho . meta # PyHC standard kamodo . rho () kamodo . rho . data # PyHC standard Original function doc strings and signatures passed through help ( kamodo . rho ) kamodo . detail ()","title":"Kamodofication"},{"location":"notebooks/Kamodo/#visualization","text":"Kamodo graphs are generated directly from function signatures by examining the structure of both output and input arguments. from plotting import plot_types plot_types Kamodo uses plotly for visualization, enabling a rich array of interactive graphs and easy web deployment. import plotly.io as pio from plotly.offline import iplot , plot , init_notebook_mode init_notebook_mode ( connected = True ) @kamodofy ( units = 'kg/m^3' ) def rho ( x = np . linspace ( 0 , 1 , 20 ), y = np . linspace ( - 1 , 1 , 40 )): \"\"\"A function that computes density\"\"\" x_ , y_ = np . meshgrid ( x , y ) return x_ * y_ kamodo = Kamodo ( rho = rho ) kamodo We will generate an image of this function using plotly fig = kamodo . plot ( 'rho' ) # pio.write_image(fig, 'images/Kamodo_fig1.svg') See the Visualization section for detailed examples.","title":"Visualization"},{"location":"notebooks/Kamodo/#latex-io","text":"Even though math is the language of physics, most scientific analysis software requires you to learn new programing languages. Kamodo allows users to write their mathematical expressions in LaTeX, a typesetting language most scientists already know: kamodo = Kamodo ( '$rho[kg/m^3] = x^3$' , '$v[cm/s] = y^2$' ) kamodo [ 'p[Pa]' ] = '$ \\\\ rho v^2$' kamodo The resulting equation set may also be exported as a LaTeX string for use in publications: print ( kamodo . to_latex () + ' \\n .' )","title":"Latex I/O"},{"location":"notebooks/Kamodo/#simulation-api","text":"Kamodo offers a simple api for functions composed of each other. Define variables as usual (order matters). kamodo = Kamodo () kamodo [ 'y_iplus1' ] = 'x_i + 1' kamodo [ 'x_iplus1' ] = 'y_i - 2' kamodo Now add the update attribute to map functions onto arguments. kamodo . x_iplus1 . update = 'x_i' kamodo . y_iplus1 . update = 'y_i' Create a simulation with initial conditions simulation = kamodo . simulate ( x_i = 0 , steps = 5 ) simulation #an iterator of arg, val dictionaries Run the simulation by iterating through the generator. import pandas as pd pd . DataFrame ( simulation ) # pandas conveniently iterates the results for display","title":"Simulation api"},{"location":"notebooks/Kamodofying_Models/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Kamodofication Tutorial \u00b6 This tutorial focuses on building a Kamodofied model from scratch. To see the full implementation, skip down to the Final-Implementation . Kamodofication requirements \u00b6 To Kamodofy models and data representing physical quantities, we need to define a set of functions representing the interpolation of each physical variable having the following properties: A function name and arguments that follows kamodo's Syntax conventions Default arrays for input arguments A meta attribute containing: 'units' - physical units of the values returned by the function 'citation' - How the model or data source should be cited 'equation' - LaTeX representation of this model/data source (if available) 'hidden_args' - A list of function arguments that should not be rendered A data attribute - The array holding the variable (if available) Any docstrings that provide further context Model Reader Tutorial \u00b6 Model Readers load data from disk (or server) and provide methods for interpolation. We require that for each variable of interest, the model reader should provide at least one interpolation method that satisfies all of the above requirements. Each model reader will: Open/close files Manage state variables Initialize interpolators Kamodofy interpolators Register functions Minimal Example: one variable \u00b6 from kamodo import Kamodo , kamodofy , gridify from scipy.interpolate import RegularGridInterpolator import numpy as np import plotly.io as pio class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg*m**-3' ) def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model we can call the registered function with multiple values, getting nan if out of bounds: model . rho ([[ 2 , 5 , 8 ], [ 0 , 0 , 0 ]]) However, the registered function has no default parameters, so an error will be raised if we do not provide an argument. try : model . rho () except TypeError as m : print ( m ) At this point, the end-user of the model cannot generate quick-look graphics: try : model . plot ( 'rho' ) except TypeError as m : print ( m ) In order to generate any plots, the user must already know where they can place resolution. For example, they could inspect some of the attributes of the model and guess the size of the domain, then choose points from that space. xx , yy , zz = np . meshgrid ( model . x , model . y , model . z ) points = np . column_stack ([ xx . ravel (), yy . ravel (), zz . ravel ()]) randints = np . random . randint ( 0 , len ( points ), 1000 ) fig = model . plot ( rho = dict ( xvec = points [ randints ] )) # pio.write_image(fig, 'images/kamodofied1.svg') Hopefully, the user doesn't choose points where the solution may be invalid. Next, we'll modify the original function to provide a griddable variable with default parameters. Including defaults \u00b6 The above example produced a kamodofied model with one variable, but we are unable to produce quick-look graphics, which required the user to inspect the model to guess where interpolation may be valid. Here we show how to include defaults so the user doesn't have to guess. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg/m**3' ) @gridify ( x = self . x , y = self . y , z = self . z ) # <--- The only change to the model def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model By adding the @gridify line, we have modified the original function to be one that generates gridded data. Moreover, the variable now has default parameters. model . rho () . shape We can now specify one or more arguments to get a plane mapping of the solution. model . rho ( z = 8 ) . shape But how do we know to choose the plane z=8 for a valid solution? We can use kamodo's function inspection to get the default ranges for each parameter. from kamodo import get_defaults get_defaults ( model . rho )[ 'z' ] . mean () Final Implementation \u00b6 In the final implementation of our model reader, we include multiple variables with different function signatures. Here, the gridded solutions have suffixes _ijk to emphasize their structure. This allows more flexibility for the end user. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz pressure_data = xx ** 2 + yy ** 2 + zz ** 2 self . variables = dict ( rho = dict ( units = 'kg/m**3' , data = density_data ), P = dict ( units = 'nPa' , data = pressure_data )) # Prepare model for function registration super ( MyModel , self ) . __init__ ( ** kwargs ) for varname in self . variables : units = self . variables [ varname ][ 'units' ] self . register_variable ( varname , units ) def register_variable ( self , varname , units ): interpolator = self . get_grid_interpolator ( varname ) # store the interpolator self . variables [ varname ][ 'interpolator' ] = interpolator def interpolate ( xvec ): return self . variables [ varname ][ 'interpolator' ]( xvec ) # update docstring for this variable interpolate . __doc__ = \"A function that returns {} in [ {} ].\" . format ( varname , units ) self [ varname ] = kamodofy ( interpolate , units = units , citation = \"Pembroke et al 2019\" , data = None ) self [ varname + '_ijk' ] = kamodofy ( gridify ( self [ varname ], x_i = self . x , y_j = self . y , z_k = self . z , squeeze = False ), units = units , citation = \"Pembroke et al 2019\" , data = self . variables [ varname ][ 'data' ]) def get_grid_interpolator ( self , varname ): \"\"\"create a regulard grid interpolator for this variable\"\"\" data = self . variables [ varname ][ 'data' ] interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), data , bounds_error = False , fill_value = self . missing_value ) return interpolator model = MyModel ( 'myfile.dat' ) model model . rho (( 2 , 5 , 8 )) model . P (( 2 , 5 , 8 )) model . detail () Here the @kamodofy decorator handles the provisioning of kamodo-specific metadata. For example, the declared function rho now has a meta attribute: model . rho . meta @kamodofy also adds the data attribute, by calling the function with its default parameters: model . rho_ijk . data . shape Combined models \u00b6 We could also register the model's interpolating method as part of some other Kamodo object, such as another kamodofied model reader or data source: from kamodo import Kamodo kamodo = Kamodo ( rho = model . rho ) kamodo We can now compose our density function with expressions defined by other models: kamodo [ 'vol' ] = '4/3 * pi * (xvec)**(3/2)' kamodo kamodo [ 'mass' ] = 'rho*vol' kamodo kamodo . detail () The following lines will save the image to your working directory. Note Saving images requires plotly-orca-1.2.1 , available through conda: conda install -c plotly plotly-orca model . rho_ijk () . shape import plotly.io as pio fig = model . plot ( rho_ijk = dict ( z_k = model . z . mean ())) from plotly.offline import iplot , init_notebook_mode , plot init_notebook_mode ( connected = True ) fig = model . plot ( rho_ijk = dict ( z_k = [ model . z . mean ()])) # pio.write_image(fig, 'kamodofied_model_1.svg', validate = False) We use markdown to embed the image into the notebook. Alternative ways to graph: ## uncomment to open interactive plot in the notebook # from plotly.offline import init_notebook_mode, iplot # init_notebook_mode(connected = True) # iplot(kamodo.plot(rho = dict(x = model.x.mean()))) # # uncomment to open interactive plot in separate tab # from plotly.offline import plot # plot(kamodo.plot(rho = dict(z = 8)))","title":"Kamodofying Models"},{"location":"notebooks/Kamodofying_Models/#kamodofication-tutorial","text":"This tutorial focuses on building a Kamodofied model from scratch. To see the full implementation, skip down to the Final-Implementation .","title":"Kamodofication Tutorial"},{"location":"notebooks/Kamodofying_Models/#kamodofication-requirements","text":"To Kamodofy models and data representing physical quantities, we need to define a set of functions representing the interpolation of each physical variable having the following properties: A function name and arguments that follows kamodo's Syntax conventions Default arrays for input arguments A meta attribute containing: 'units' - physical units of the values returned by the function 'citation' - How the model or data source should be cited 'equation' - LaTeX representation of this model/data source (if available) 'hidden_args' - A list of function arguments that should not be rendered A data attribute - The array holding the variable (if available) Any docstrings that provide further context","title":"Kamodofication requirements"},{"location":"notebooks/Kamodofying_Models/#model-reader-tutorial","text":"Model Readers load data from disk (or server) and provide methods for interpolation. We require that for each variable of interest, the model reader should provide at least one interpolation method that satisfies all of the above requirements. Each model reader will: Open/close files Manage state variables Initialize interpolators Kamodofy interpolators Register functions","title":"Model Reader Tutorial"},{"location":"notebooks/Kamodofying_Models/#minimal-example-one-variable","text":"from kamodo import Kamodo , kamodofy , gridify from scipy.interpolate import RegularGridInterpolator import numpy as np import plotly.io as pio class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg*m**-3' ) def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model we can call the registered function with multiple values, getting nan if out of bounds: model . rho ([[ 2 , 5 , 8 ], [ 0 , 0 , 0 ]]) However, the registered function has no default parameters, so an error will be raised if we do not provide an argument. try : model . rho () except TypeError as m : print ( m ) At this point, the end-user of the model cannot generate quick-look graphics: try : model . plot ( 'rho' ) except TypeError as m : print ( m ) In order to generate any plots, the user must already know where they can place resolution. For example, they could inspect some of the attributes of the model and guess the size of the domain, then choose points from that space. xx , yy , zz = np . meshgrid ( model . x , model . y , model . z ) points = np . column_stack ([ xx . ravel (), yy . ravel (), zz . ravel ()]) randints = np . random . randint ( 0 , len ( points ), 1000 ) fig = model . plot ( rho = dict ( xvec = points [ randints ] )) # pio.write_image(fig, 'images/kamodofied1.svg') Hopefully, the user doesn't choose points where the solution may be invalid. Next, we'll modify the original function to provide a griddable variable with default parameters.","title":"Minimal Example: one variable"},{"location":"notebooks/Kamodofying_Models/#including-defaults","text":"The above example produced a kamodofied model with one variable, but we are unable to produce quick-look graphics, which required the user to inspect the model to guess where interpolation may be valid. Here we show how to include defaults so the user doesn't have to guess. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz self . interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), density_data , bounds_error = False , fill_value = self . missing_value ) # Prepare model for function registration for the input argument super ( MyModel , self ) . __init__ ( ** kwargs ) # Wrap the interpolator with a nicer function signature @kamodofy ( units = 'kg/m**3' ) @gridify ( x = self . x , y = self . y , z = self . z ) # <--- The only change to the model def interpolator ( xvec ): return self . interpolator ( xvec ) self [ 'rho' ] = interpolator model = MyModel ( 'myfile.dat' ) model By adding the @gridify line, we have modified the original function to be one that generates gridded data. Moreover, the variable now has default parameters. model . rho () . shape We can now specify one or more arguments to get a plane mapping of the solution. model . rho ( z = 8 ) . shape But how do we know to choose the plane z=8 for a valid solution? We can use kamodo's function inspection to get the default ranges for each parameter. from kamodo import get_defaults get_defaults ( model . rho )[ 'z' ] . mean ()","title":"Including defaults"},{"location":"notebooks/Kamodofying_Models/#final-implementation","text":"In the final implementation of our model reader, we include multiple variables with different function signatures. Here, the gridded solutions have suffixes _ijk to emphasize their structure. This allows more flexibility for the end user. class MyModel ( Kamodo ): def __init__ ( self , filename , ** kwargs ): # perform any necessary I/O print ( 'opening {} ' . format ( filename )) self . filename = filename self . missing_value = np . NAN # store any data needed for interpolation self . x = np . linspace ( 1 , 4 , 11 ) self . y = np . linspace ( 4 , 7 , 22 ) self . z = np . linspace ( 7 , 9 , 33 ) xx , yy , zz = np . meshgrid ( self . x , self . y , self . z , indexing = 'ij' , sparse = True ) density_data = 2 * xx ** 3 + 3 * yy ** 2 - zz pressure_data = xx ** 2 + yy ** 2 + zz ** 2 self . variables = dict ( rho = dict ( units = 'kg/m**3' , data = density_data ), P = dict ( units = 'nPa' , data = pressure_data )) # Prepare model for function registration super ( MyModel , self ) . __init__ ( ** kwargs ) for varname in self . variables : units = self . variables [ varname ][ 'units' ] self . register_variable ( varname , units ) def register_variable ( self , varname , units ): interpolator = self . get_grid_interpolator ( varname ) # store the interpolator self . variables [ varname ][ 'interpolator' ] = interpolator def interpolate ( xvec ): return self . variables [ varname ][ 'interpolator' ]( xvec ) # update docstring for this variable interpolate . __doc__ = \"A function that returns {} in [ {} ].\" . format ( varname , units ) self [ varname ] = kamodofy ( interpolate , units = units , citation = \"Pembroke et al 2019\" , data = None ) self [ varname + '_ijk' ] = kamodofy ( gridify ( self [ varname ], x_i = self . x , y_j = self . y , z_k = self . z , squeeze = False ), units = units , citation = \"Pembroke et al 2019\" , data = self . variables [ varname ][ 'data' ]) def get_grid_interpolator ( self , varname ): \"\"\"create a regulard grid interpolator for this variable\"\"\" data = self . variables [ varname ][ 'data' ] interpolator = RegularGridInterpolator (( self . x , self . y , self . z ), data , bounds_error = False , fill_value = self . missing_value ) return interpolator model = MyModel ( 'myfile.dat' ) model model . rho (( 2 , 5 , 8 )) model . P (( 2 , 5 , 8 )) model . detail () Here the @kamodofy decorator handles the provisioning of kamodo-specific metadata. For example, the declared function rho now has a meta attribute: model . rho . meta @kamodofy also adds the data attribute, by calling the function with its default parameters: model . rho_ijk . data . shape","title":"Final Implementation"},{"location":"notebooks/Kamodofying_Models/#combined-models","text":"We could also register the model's interpolating method as part of some other Kamodo object, such as another kamodofied model reader or data source: from kamodo import Kamodo kamodo = Kamodo ( rho = model . rho ) kamodo We can now compose our density function with expressions defined by other models: kamodo [ 'vol' ] = '4/3 * pi * (xvec)**(3/2)' kamodo kamodo [ 'mass' ] = 'rho*vol' kamodo kamodo . detail () The following lines will save the image to your working directory. Note Saving images requires plotly-orca-1.2.1 , available through conda: conda install -c plotly plotly-orca model . rho_ijk () . shape import plotly.io as pio fig = model . plot ( rho_ijk = dict ( z_k = model . z . mean ())) from plotly.offline import iplot , init_notebook_mode , plot init_notebook_mode ( connected = True ) fig = model . plot ( rho_ijk = dict ( z_k = [ model . z . mean ()])) # pio.write_image(fig, 'kamodofied_model_1.svg', validate = False) We use markdown to embed the image into the notebook. Alternative ways to graph: ## uncomment to open interactive plot in the notebook # from plotly.offline import init_notebook_mode, iplot # init_notebook_mode(connected = True) # iplot(kamodo.plot(rho = dict(x = model.x.mean()))) # # uncomment to open interactive plot in separate tab # from plotly.offline import plot # plot(kamodo.plot(rho = dict(z = 8)))","title":"Combined models"},{"location":"notebooks/Syntax/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); from kamodo.kamodo import Kamodo LaTeX support \u00b6 Kamodo supports both python and LaTex-formatted expressions as input. For LaTeX, you must wrap your expression in $ $ : Kamodo ( f = 'x**2 + y**2' , g = '$2x^2 + 3y^2$' ) \\begin{equation}f{\\left(x,y \\right)} = x^{2} + y^{2}\\end{equation}\\begin{equation}g{\\left(x,y \\right)} = 2 x^{2} + 3 y^{2}\\end{equation} Conventions \u00b6 Kamodo's variable names have to follow python's naming conventions - only numbers, letters, and underscores, which are too restrictive for mathematical symbols. Therefore, Kamodo uses sympy's conventions when generating LaTeX from variable names, which provide a means to write mathematical symbols in a way ammenable to python. More details of sympy's conventions may be found here . Kamodo also adds some additional features not covered by sympy. Superscripts/Subscripts \u00b6 Subscripts are encoded with single underscores. Superscripts are encoded with double underscores. Combinations are possible. Kamodo ( 'x_i = a' , 'y__j = b' , 'z_oxygen__2 = c' ) \\begin{equation}\\operatorname{x_{i}}{\\left(a \\right)} = a\\end{equation}\\begin{equation}\\operatorname{y^{j}}{\\left(b \\right)} = b\\end{equation}\\begin{equation}\\operatorname{z^{2}_{oxygen}}{\\left(c \\right)} = c\\end{equation} Greek letters \u00b6 Most greek letters are supported using their corresponding english name. Use capitalization if the greek letter should also be capitalized. Kamodo ( rho = 'ALPHA+BETA+Gamma' ) \\begin{equation}\\rho{\\left(\\alpha,\\beta,\\Gamma \\right)} = \\alpha + \\beta + \\Gamma\\end{equation} Warning Some greek letters (e.g. pi, zeta) may conflict with Sympy's namespace. In that case, use all caps (e.g. PI, ZETA) plus/minus operators \u00b6 In Python we cannot have variables embedded with + or - , but we may still need these symbols to represent, say ionization or simulation time step. The table below shows how we map from (part of) a variable name to its corresponding latex output. variable to latex plus + minus - comma , LEFT \\\\left ( RIGHT \\\\right ) prime ' Here is how you would use these in your functions: Kamodo ( x_iplus1 = 'x_i*.9' , O__minus = 'e**-h' , OLEFT3PRIGHT = 't' , fprime = 'x' ) \\begin{equation}\\operatorname{x_{i+1}}{\\left(x_{i} \\right)} = 0.9 x_{i}\\end{equation}\\begin{equation}\\operatorname{O^{-}}{\\left(e,h \\right)} = e^{- h}\\end{equation}\\begin{equation}\\operatorname{O\\left (3P\\right )}{\\left(t \\right)} = t\\end{equation}\\begin{equation}\\operatorname{{f}'}{\\left(x \\right)} = x\\end{equation} Variable reuse \u00b6 Variables may only have one function representing their evaluation. If you try to define a variable twice, the second version will override the first. However, if you want to represent that variable in a different context but keep using its name, there are two options: Annotation - add superscripts/subscripts to distinguish between the different implentations. Mimicry - use a new name that produces the same LaTeX output. Kamodo ( rho = 'x + y + z' , RHO = 'r*sin(theta)*cos(phi)' , rho_2D = 'x + y' ) \\begin{equation}\\rho{\\left(x,y,z \\right)} = x + y + z\\end{equation}\\begin{equation}\\rho{\\left(\\phi,r,\\theta \\right)} = r \\sin{\\left(\\theta \\right)} \\cos{\\left(\\phi \\right)}\\end{equation}\\begin{equation}\\rho_{2D}{\\left(x,y \\right)} = x + y\\end{equation} Warning Mimicry can cause confusion if the signature of the left-hand-side does not change, as in the example below: Kamodo ( rho = 'x + y' , RHO = '3*x + y' ) \\begin{equation}\\rho{\\left(x,y \\right)} = x + y\\end{equation}\\begin{equation}\\rho{\\left(x,y \\right)} = 3 x + y\\end{equation}","title":"Syntax"},{"location":"notebooks/Syntax/#latex-support","text":"Kamodo supports both python and LaTex-formatted expressions as input. For LaTeX, you must wrap your expression in $ $ : Kamodo ( f = 'x**2 + y**2' , g = '$2x^2 + 3y^2$' ) \\begin{equation}f{\\left(x,y \\right)} = x^{2} + y^{2}\\end{equation}\\begin{equation}g{\\left(x,y \\right)} = 2 x^{2} + 3 y^{2}\\end{equation}","title":"LaTeX support"},{"location":"notebooks/Syntax/#conventions","text":"Kamodo's variable names have to follow python's naming conventions - only numbers, letters, and underscores, which are too restrictive for mathematical symbols. Therefore, Kamodo uses sympy's conventions when generating LaTeX from variable names, which provide a means to write mathematical symbols in a way ammenable to python. More details of sympy's conventions may be found here . Kamodo also adds some additional features not covered by sympy.","title":"Conventions"},{"location":"notebooks/Syntax/#superscriptssubscripts","text":"Subscripts are encoded with single underscores. Superscripts are encoded with double underscores. Combinations are possible. Kamodo ( 'x_i = a' , 'y__j = b' , 'z_oxygen__2 = c' ) \\begin{equation}\\operatorname{x_{i}}{\\left(a \\right)} = a\\end{equation}\\begin{equation}\\operatorname{y^{j}}{\\left(b \\right)} = b\\end{equation}\\begin{equation}\\operatorname{z^{2}_{oxygen}}{\\left(c \\right)} = c\\end{equation}","title":"Superscripts/Subscripts"},{"location":"notebooks/Syntax/#greek-letters","text":"Most greek letters are supported using their corresponding english name. Use capitalization if the greek letter should also be capitalized. Kamodo ( rho = 'ALPHA+BETA+Gamma' ) \\begin{equation}\\rho{\\left(\\alpha,\\beta,\\Gamma \\right)} = \\alpha + \\beta + \\Gamma\\end{equation} Warning Some greek letters (e.g. pi, zeta) may conflict with Sympy's namespace. In that case, use all caps (e.g. PI, ZETA)","title":"Greek letters"},{"location":"notebooks/Syntax/#plusminus-operators","text":"In Python we cannot have variables embedded with + or - , but we may still need these symbols to represent, say ionization or simulation time step. The table below shows how we map from (part of) a variable name to its corresponding latex output. variable to latex plus + minus - comma , LEFT \\\\left ( RIGHT \\\\right ) prime ' Here is how you would use these in your functions: Kamodo ( x_iplus1 = 'x_i*.9' , O__minus = 'e**-h' , OLEFT3PRIGHT = 't' , fprime = 'x' ) \\begin{equation}\\operatorname{x_{i+1}}{\\left(x_{i} \\right)} = 0.9 x_{i}\\end{equation}\\begin{equation}\\operatorname{O^{-}}{\\left(e,h \\right)} = e^{- h}\\end{equation}\\begin{equation}\\operatorname{O\\left (3P\\right )}{\\left(t \\right)} = t\\end{equation}\\begin{equation}\\operatorname{{f}'}{\\left(x \\right)} = x\\end{equation}","title":"plus/minus operators"},{"location":"notebooks/Syntax/#variable-reuse","text":"Variables may only have one function representing their evaluation. If you try to define a variable twice, the second version will override the first. However, if you want to represent that variable in a different context but keep using its name, there are two options: Annotation - add superscripts/subscripts to distinguish between the different implentations. Mimicry - use a new name that produces the same LaTeX output. Kamodo ( rho = 'x + y + z' , RHO = 'r*sin(theta)*cos(phi)' , rho_2D = 'x + y' ) \\begin{equation}\\rho{\\left(x,y,z \\right)} = x + y + z\\end{equation}\\begin{equation}\\rho{\\left(\\phi,r,\\theta \\right)} = r \\sin{\\left(\\theta \\right)} \\cos{\\left(\\phi \\right)}\\end{equation}\\begin{equation}\\rho_{2D}{\\left(x,y \\right)} = x + y\\end{equation} Warning Mimicry can cause confusion if the signature of the left-hand-side does not change, as in the example below: Kamodo ( rho = 'x + y' , RHO = '3*x + y' ) \\begin{equation}\\rho{\\left(x,y \\right)} = x + y\\end{equation}\\begin{equation}\\rho{\\left(x,y \\right)} = 3 x + y\\end{equation}","title":"Variable reuse"},{"location":"notebooks/Untitled/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); from kamodo import Kamodo , kamodofy @kamodofy ( units = 'kg' ) def mass ( x ): return x ** 2 @kamodofy ( units = 'm^3' ) def vol ( y ): return y ** 2 k = Kamodo ( mass = mass , vol = vol ) k [ 'rho' ] = 'mass/vol' k \\begin{equation}\\operatorname{mass}{\\left(x \\right)}[kg] = \\lambda{\\left(x \\right)}\\end{equation} \\begin{equation}\\operatorname{vol}{\\left(y \\right)}[m^{3}] = \\lambda{\\left(y \\right)}\\end{equation} \\begin{equation}\\rho{\\left(y,x \\right)}[\\frac{kg}{m^{3}}] = \\frac{\\operatorname{mass}{\\left(x \\right)}}{\\operatorname{vol}{\\left(y \\right)}}\\end{equation} k [ 'rho(x,y)' ] = 'mass/vol' Traceback (most recent call last) : File \"/Users/asherp/opt/miniconda3/envs/ensemble/lib/python3.7/site-packages/IPython/core/interactiveshell.py\" , line 3444 , in run_code exec(code_obj, self.user_global_ns, self.user_ns) File \"/var/folders/ry/3vf8_b9131zcv7f3fjb1fpcm0000gn/T/ipykernel_67707/4025623704.py\" , line 1 , in <module> k['rho(x,y)'] = 'mass/vol' File \"/Users/asherp/git/ensemblegovservices/kamodo-core/kamodo/kamodo.py\" , line 575 , in __setitem__ raise SyntaxError('Ordering error') File \"<string>\" , line unknown SyntaxError : Ordering error","title":"Untitled"},{"location":"notebooks/Visualization/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Visualization \u00b6 Overview \u00b6 Visualization poses a significant challenge for the space weather community: output from models and data are very domain-specific, both in content (coordinate systems, units) and in representation (file formats and data structures). On the other hand, science users also have their preferred context for analyzing these results - for instance, they may only want simulation results interpolated on a satellite trajectory and in a specific coordinate system with their own prefered units. Kamodo aims to strike a balance between the intent of the model (or data) provider and the goals of the user, by making it easy for developers to provide context for their output and for users to easily change that context. It accomplishes this in two ways: By leveraging default arguments given by model and data providers By mapping the shape of function inputs and output to certain registered plot types This strategy allows Kamodo to automatically generate plots for arbitrary model output and data sources, while still allowing for customization by the end user. Available Plot Types \u00b6 Kamodo keeps a registry of plotting functions, indexed by argument shape and output shape. from kamodo.plotting import plot_types plot_types When a user tries to plot a given variable, a lookup is made into the table above and the corresponding plotting function is used to generate the output. Examples below demonstrate the intended workflow. 1-Dimensional line plots \u00b6 from kamodo import Kamodo , kamodofy kamodo = Kamodo ( 'g_N[kg] = x_N**2' ) kamodo [ 'f[g]' ] = 'g_N' kamodo Here we have defined a function g_N which returns an array of shape N . As input, it takes one argument x_N which also has size N . We also generate a function f which is the same as g_N but with a different units. Note We could have named the function g instead of g_N . The variable names have no bearing on the resulting plots - only the argument input shapes and output shapes matter. When we call Kamodo's plot function, we define which variable we are plotting and domain over which the arguments are applied: import numpy as np import plotly.io as pio fig = kamodo . plot ( f = dict ( x_N = np . linspace ( - 4 , 3 , 30 ))) # pio.write_image(fig, 'images/1d-line.svg') This is the graph f(x_n) for x_N \\in [-4,3] . Time series data \u00b6 The process for time series data is the same, except we use a pandas datetime index for the input argument. import pandas as pd t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , verbose = False ) kamodo fig = kamodo . plot ( 'rho_N' ) In this case, we only need to name the variable we wish to plot, because we have already defined a function rho_N(t_N) with a default parameter for t_N . # pio.write_image(fig, 'images/1d-time-series.svg') Note By providing default parameters, the function author can insure that anyone plotting the variable will not need to know where to place resolution! 2-D Parametric charts \u00b6 For 2-D Plots, the output function must have input shape (N,1) and output shape (N,2) . from kamodo import Kamodo @kamodofy ( units = 'cm' ) def x_Ncomma2 ( theta_N = np . linspace ( 0 , 6 * np . pi , 200 )): r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) return np . array ( list ( zip ( x , y ))) kamodo = Kamodo ( x_Ncomma2 = x_Ncomma2 ) kamodo Here, we again provide a default array for \\theta_N so the end user does not need to: fig = kamodo . plot ( 'x_Ncomma2' ) # pio.write_image(fig, 'images/fig-2d.svg') 3-Dimensional parametric curves \u00b6 For 3-D parametric curves, the output function must have input shape (N,1) and output shape (N,3) . @kamodofy ( units = 'km' ) def x_Ncomma3 ( t_N = pd . date_range ( 'Nov 12, 2018' , 'Dec 30, 2018' , freq = '4 H' )): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) theta = dt_days * np . pi / 5 r = theta x = r * np . cos ( theta ) y = r * np . sin ( theta ) z = r return np . array ( list ( zip ( x , y , z ))) kamodo = Kamodo ( x_Ncomma3 = x_Ncomma3 ) kamodo fig = kamodo . plot ( 'x_Ncomma3' ) # pio.write_image(fig, 'images/3d-line.svg') Functions of three N-d arrays are also interpreted as 3D parametric plots, but with an additonal color component. s = np . linspace ( 0 , 8 * np . pi , 100 ) x = 10 * np . sin ( s / 8 ) y = 10 * np . sin ( s ) z = s @kamodofy ( units = 'kg' ) def f_N ( x_N = x , y_N = y , z_N = z ): return x_N ** 2 + y_N ** 2 + z_N ** 2 kamodo = Kamodo ( f_N = f_N ) kamodo fig = kamodo . plot ( 'f_N' ) # pio.write_image(fig, 'images/3d-points.svg') Vector fields \u00b6 Kamodo generates a 2-d vector (quiver) plot for functions of one variable, if both the input and output have shape (N,2). The input positions are assumed to be x , y and the output vectors are assumed to be v_x , v_y theta_N = np . linspace ( 0 , 6 * np . pi , 200 ) r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) points = np . array ( list ( zip ( x , y ))) @kamodofy ( units = 'cm' ) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): return rvec_Ncomma2 kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector.svg') If we wish to represent a grid of vectors, we must first unravel the grid as a string of points. x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): ux = np . sin ( rvec_Ncomma2 [:, 0 ]) uy = np . cos ( rvec_Ncomma2 [:, 1 ]) return np . vstack (( ux , uy )) . T kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector-field.svg') 3D vector fields \u00b6 Functions representing 3D vector fields should have one argument of shape (N,3) and an output shape of (N,3) x , y , z = np . meshgrid ( np . linspace ( - 2 , 2 , 4 ), np . linspace ( - 3 , 3 , 6 ), np . linspace ( - 5 , 5 , 10 )) points = np . array ( list ( zip ( x . ravel (), y . ravel (), z . ravel ()))) def fvec_Ncomma3 ( rvec_Ncomma3 = points ): return rvec_Ncomma3 kamodo = Kamodo ( fvec_Ncomma3 = fvec_Ncomma3 ) kamodo fig = kamodo . plot ( 'fvec_Ncomma3' ) # pio.write_image(fig, 'images/fig3d-vector.svg') Contour plots \u00b6 Scalar functions of two variables of size (N) and (M) and output size (N,M) will generate contour plots. Kamodo can handle both ij indexing and xy indexing. from kamodo import Kamodo @kamodofy ( units = 'cm^2' ) def f_NcommaM ( x_N = np . linspace ( 0 , 8 * np . pi , 100 ), y_M = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_M , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NcommaM = f_NcommaM ) kamodo fig = kamodo . plot ( 'f_NcommaM' ) # pio.write_image(fig, 'images/fig2d-contour.svg') Since x_N and y_M have differnt sizes, we could have used indexing=ij as an argument to meshgrid and kamodo would have produced the same figure - Kamodo swaps the ordering where appropriate. In the event that both arguments have the same size, we can pass an indexing argument as an option to the plot function. @kamodofy ( units = 'cm**2' ) def f_NN ( x_N = np . linspace ( 0 , 8 * np . pi , 90 ), y_N = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_N , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NN = f_NN ) kamodo fig = kamodo . plot ( f_NN = dict ( indexing = 'xy' )) # pio.write_image(fig, 'images/fig2d-contour-xy.svg') Skew (Carpet) Plots \u00b6 Functions of two arguments each having shape (N,M) matching the output shape will produce skewed contour plots, whereby the x and y components of the grid are independent. r = np . linspace ( 1 , 3 , 20 ) theta = np . linspace ( 0 , np . pi , 14 ) r_ , theta_ = np . meshgrid ( r , theta ) XX = r_ * np . cos ( theta_ ) YY = r_ * np . sin ( theta_ ) @kamodofy ( units = 'cm**2' ) def f_NM ( x_NM = XX , y_NM = YY ): return np . sin ( x_NM ) + y_NM kamodo = Kamodo ( f_NM = f_NM ) kamodo fig = kamodo . plot ( 'f_NM' ) # pio.write_image(fig, 'images/fig2d-skew.svg') Parametric surfaces \u00b6 To generate a purely geometrical parametric surface, supply a functions of three variables, each of size (N,M) and of output shape (1). from kamodo import Kamodo u = np . linspace ( - 2 , 2 , 40 ) v = np . linspace ( - 2 , 2 , 50 ) uu , vv = np . meshgrid ( u , v ) @kamodofy ( units = 'cm' ) def parametric ( x_NM = uu * np . sin ( vv * np . pi ), y_NM = vv , z_NM = np . exp ( - uu ** 2 - vv ** 2 )): return np . array ([ 1 ]) kamodo = Kamodo ( p = parametric ) kamodo fig = kamodo . plot ( 'p' ) # pio.write_image(fig, 'images/3d-parametric.svg') To control the color of the parametric surface, have the output shape be (N,M). R = 1 theta = np . linspace ( .2 * np . pi , .8 * np . pi , 40 ) phi = np . linspace ( 0 , 2 * np . pi , 50 ) theta_ , phi_ = np . meshgrid ( theta , phi ) r = ( R + .1 * ( np . cos ( 10 * theta_ ) * np . sin ( 14 * phi_ ))) xx = r * np . sin ( theta_ ) * np . cos ( phi_ ) yy = r * np . sin ( theta_ ) * np . sin ( phi_ ) zz = r * np . cos ( theta_ ) @kamodofy ( units = 'cm' ) def spherelike ( x_NM = xx , y_NM = yy , z_NM = zz ): return .1 * x_NM + x_NM ** 2 + y_NM ** 2 + z_NM ** 2 kamodo = Kamodo ( h_NM = spherelike ) kamodo fig = kamodo . plot ( 'h_NM' ) # pio.write_image(fig, 'images/3d-parametric-color.svg') Map-to-plane \u00b6 We often need to produce slices through a volumetric grid of data. This may be accomplished through the use of volumetric grid interpolators equipped with default values for each of the input arguments. Suppose such a function has default input arguments of size (L), (M), (N), and output shape (L,M,N), then a cartesian plane will be generated if the user overrides one of these defaults (e.g. setting L = 1 ). @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN ) kamodo fig = kamodo . plot ( f_LMN = dict ( z_N = - 5 )) # pio.write_image(fig,'images/fig2d-map-to-plane.svg') Tip By providing appropriate defaults for the undelying grid structure, the interpolator author can ensure that the user can generate figures with optimal resolution! Multiple traces \u00b6 Kamodo supports multiple traces in the same figure. Simply provide plot with multiple function-argument pairs. from kamodo import Kamodo t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) @kamodofy ( units = 'nPa' ) def p_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( 2 * dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , p_N = p_N , verbose = False ) kamodo fig = kamodo . plot ( 'p_N' , 'rho_N' ) # pio.write_image(fig, 'images/multi-trace.svg') Note Plot types must be compatible for kamodo to plot different variables on the same axes. Kamodo can also handle multiple traces in 3D from kamodo import Kamodo , kamodofy @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN , g_LMN = f_LMN ) kamodo fig = kamodo . plot ( f_LMN = dict ( z_N = 0 ), g_LMN = dict ( y_M = 5 )) # pio.write_image(fig, 'images/multi-trace3d.svg') Bug Multiple traces results in different colorbars which may overlap. More control over the layout will be available in future updates. Interactive Plotting \u00b6 For interactive 3d plots, we take advantage of Plotly's in-browser plotting library. from plotly.offline import iplot , plot , init_notebook_mode To generate a separate interactive html page, use iplot instead of plot : # plot(fig, filename = 'sample_plot.html') #uncomment to render 3D interactive plot in this cell navigate to the 3d interactive plot: sample_plot.html . Alternatively, you may work with interactive plots directly in jupyter notebooks: # init_notebook_mode() # uncomment to initialize plotly for notebook # iplot(fig) #uncomment to render 3D interactive plot in this cell Note We have commented out the above lines because they do not render properly on the documentation server, but rest assured they do work!","title":"Visualization"},{"location":"notebooks/Visualization/#visualization","text":"","title":"Visualization"},{"location":"notebooks/Visualization/#overview","text":"Visualization poses a significant challenge for the space weather community: output from models and data are very domain-specific, both in content (coordinate systems, units) and in representation (file formats and data structures). On the other hand, science users also have their preferred context for analyzing these results - for instance, they may only want simulation results interpolated on a satellite trajectory and in a specific coordinate system with their own prefered units. Kamodo aims to strike a balance between the intent of the model (or data) provider and the goals of the user, by making it easy for developers to provide context for their output and for users to easily change that context. It accomplishes this in two ways: By leveraging default arguments given by model and data providers By mapping the shape of function inputs and output to certain registered plot types This strategy allows Kamodo to automatically generate plots for arbitrary model output and data sources, while still allowing for customization by the end user.","title":"Overview"},{"location":"notebooks/Visualization/#available-plot-types","text":"Kamodo keeps a registry of plotting functions, indexed by argument shape and output shape. from kamodo.plotting import plot_types plot_types When a user tries to plot a given variable, a lookup is made into the table above and the corresponding plotting function is used to generate the output. Examples below demonstrate the intended workflow.","title":"Available Plot Types"},{"location":"notebooks/Visualization/#1-dimensional-line-plots","text":"from kamodo import Kamodo , kamodofy kamodo = Kamodo ( 'g_N[kg] = x_N**2' ) kamodo [ 'f[g]' ] = 'g_N' kamodo Here we have defined a function g_N which returns an array of shape N . As input, it takes one argument x_N which also has size N . We also generate a function f which is the same as g_N but with a different units. Note We could have named the function g instead of g_N . The variable names have no bearing on the resulting plots - only the argument input shapes and output shapes matter. When we call Kamodo's plot function, we define which variable we are plotting and domain over which the arguments are applied: import numpy as np import plotly.io as pio fig = kamodo . plot ( f = dict ( x_N = np . linspace ( - 4 , 3 , 30 ))) # pio.write_image(fig, 'images/1d-line.svg') This is the graph f(x_n) for x_N \\in [-4,3] .","title":"1-Dimensional line plots"},{"location":"notebooks/Visualization/#time-series-data","text":"The process for time series data is the same, except we use a pandas datetime index for the input argument. import pandas as pd t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , verbose = False ) kamodo fig = kamodo . plot ( 'rho_N' ) In this case, we only need to name the variable we wish to plot, because we have already defined a function rho_N(t_N) with a default parameter for t_N . # pio.write_image(fig, 'images/1d-time-series.svg') Note By providing default parameters, the function author can insure that anyone plotting the variable will not need to know where to place resolution!","title":"Time series data"},{"location":"notebooks/Visualization/#2-d-parametric-charts","text":"For 2-D Plots, the output function must have input shape (N,1) and output shape (N,2) . from kamodo import Kamodo @kamodofy ( units = 'cm' ) def x_Ncomma2 ( theta_N = np . linspace ( 0 , 6 * np . pi , 200 )): r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) return np . array ( list ( zip ( x , y ))) kamodo = Kamodo ( x_Ncomma2 = x_Ncomma2 ) kamodo Here, we again provide a default array for \\theta_N so the end user does not need to: fig = kamodo . plot ( 'x_Ncomma2' ) # pio.write_image(fig, 'images/fig-2d.svg')","title":"2-D Parametric charts"},{"location":"notebooks/Visualization/#3-dimensional-parametric-curves","text":"For 3-D parametric curves, the output function must have input shape (N,1) and output shape (N,3) . @kamodofy ( units = 'km' ) def x_Ncomma3 ( t_N = pd . date_range ( 'Nov 12, 2018' , 'Dec 30, 2018' , freq = '4 H' )): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) theta = dt_days * np . pi / 5 r = theta x = r * np . cos ( theta ) y = r * np . sin ( theta ) z = r return np . array ( list ( zip ( x , y , z ))) kamodo = Kamodo ( x_Ncomma3 = x_Ncomma3 ) kamodo fig = kamodo . plot ( 'x_Ncomma3' ) # pio.write_image(fig, 'images/3d-line.svg') Functions of three N-d arrays are also interpreted as 3D parametric plots, but with an additonal color component. s = np . linspace ( 0 , 8 * np . pi , 100 ) x = 10 * np . sin ( s / 8 ) y = 10 * np . sin ( s ) z = s @kamodofy ( units = 'kg' ) def f_N ( x_N = x , y_N = y , z_N = z ): return x_N ** 2 + y_N ** 2 + z_N ** 2 kamodo = Kamodo ( f_N = f_N ) kamodo fig = kamodo . plot ( 'f_N' ) # pio.write_image(fig, 'images/3d-points.svg')","title":"3-Dimensional parametric curves"},{"location":"notebooks/Visualization/#vector-fields","text":"Kamodo generates a 2-d vector (quiver) plot for functions of one variable, if both the input and output have shape (N,2). The input positions are assumed to be x , y and the output vectors are assumed to be v_x , v_y theta_N = np . linspace ( 0 , 6 * np . pi , 200 ) r = theta_N x = r * np . cos ( theta_N ) y = r * np . sin ( theta_N ) points = np . array ( list ( zip ( x , y ))) @kamodofy ( units = 'cm' ) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): return rvec_Ncomma2 kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector.svg') If we wish to represent a grid of vectors, we must first unravel the grid as a string of points. x = np . linspace ( - np . pi , np . pi , 25 ) y = np . linspace ( - np . pi , np . pi , 30 ) xx , yy = np . meshgrid ( x , y ) points = np . array ( list ( zip ( xx . ravel (), yy . ravel ()))) def fvec_Ncomma2 ( rvec_Ncomma2 = points ): ux = np . sin ( rvec_Ncomma2 [:, 0 ]) uy = np . cos ( rvec_Ncomma2 [:, 1 ]) return np . vstack (( ux , uy )) . T kamodo = Kamodo ( fvec_Ncomma2 = fvec_Ncomma2 ) kamodo fig = kamodo . plot ( 'fvec_Ncomma2' ) # pio.write_image(fig, 'images/fig2d-vector-field.svg')","title":"Vector fields"},{"location":"notebooks/Visualization/#3d-vector-fields","text":"Functions representing 3D vector fields should have one argument of shape (N,3) and an output shape of (N,3) x , y , z = np . meshgrid ( np . linspace ( - 2 , 2 , 4 ), np . linspace ( - 3 , 3 , 6 ), np . linspace ( - 5 , 5 , 10 )) points = np . array ( list ( zip ( x . ravel (), y . ravel (), z . ravel ()))) def fvec_Ncomma3 ( rvec_Ncomma3 = points ): return rvec_Ncomma3 kamodo = Kamodo ( fvec_Ncomma3 = fvec_Ncomma3 ) kamodo fig = kamodo . plot ( 'fvec_Ncomma3' ) # pio.write_image(fig, 'images/fig3d-vector.svg')","title":"3D vector fields"},{"location":"notebooks/Visualization/#contour-plots","text":"Scalar functions of two variables of size (N) and (M) and output size (N,M) will generate contour plots. Kamodo can handle both ij indexing and xy indexing. from kamodo import Kamodo @kamodofy ( units = 'cm^2' ) def f_NcommaM ( x_N = np . linspace ( 0 , 8 * np . pi , 100 ), y_M = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_M , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NcommaM = f_NcommaM ) kamodo fig = kamodo . plot ( 'f_NcommaM' ) # pio.write_image(fig, 'images/fig2d-contour.svg') Since x_N and y_M have differnt sizes, we could have used indexing=ij as an argument to meshgrid and kamodo would have produced the same figure - Kamodo swaps the ordering where appropriate. In the event that both arguments have the same size, we can pass an indexing argument as an option to the plot function. @kamodofy ( units = 'cm**2' ) def f_NN ( x_N = np . linspace ( 0 , 8 * np . pi , 90 ), y_N = np . linspace ( 0 , 5 , 90 )): x , y = np . meshgrid ( x_N , y_N , indexing = 'xy' ) return np . sin ( x ) * y kamodo = Kamodo ( f_NN = f_NN ) kamodo fig = kamodo . plot ( f_NN = dict ( indexing = 'xy' )) # pio.write_image(fig, 'images/fig2d-contour-xy.svg')","title":"Contour plots"},{"location":"notebooks/Visualization/#skew-carpet-plots","text":"Functions of two arguments each having shape (N,M) matching the output shape will produce skewed contour plots, whereby the x and y components of the grid are independent. r = np . linspace ( 1 , 3 , 20 ) theta = np . linspace ( 0 , np . pi , 14 ) r_ , theta_ = np . meshgrid ( r , theta ) XX = r_ * np . cos ( theta_ ) YY = r_ * np . sin ( theta_ ) @kamodofy ( units = 'cm**2' ) def f_NM ( x_NM = XX , y_NM = YY ): return np . sin ( x_NM ) + y_NM kamodo = Kamodo ( f_NM = f_NM ) kamodo fig = kamodo . plot ( 'f_NM' ) # pio.write_image(fig, 'images/fig2d-skew.svg')","title":"Skew (Carpet) Plots"},{"location":"notebooks/Visualization/#parametric-surfaces","text":"To generate a purely geometrical parametric surface, supply a functions of three variables, each of size (N,M) and of output shape (1). from kamodo import Kamodo u = np . linspace ( - 2 , 2 , 40 ) v = np . linspace ( - 2 , 2 , 50 ) uu , vv = np . meshgrid ( u , v ) @kamodofy ( units = 'cm' ) def parametric ( x_NM = uu * np . sin ( vv * np . pi ), y_NM = vv , z_NM = np . exp ( - uu ** 2 - vv ** 2 )): return np . array ([ 1 ]) kamodo = Kamodo ( p = parametric ) kamodo fig = kamodo . plot ( 'p' ) # pio.write_image(fig, 'images/3d-parametric.svg') To control the color of the parametric surface, have the output shape be (N,M). R = 1 theta = np . linspace ( .2 * np . pi , .8 * np . pi , 40 ) phi = np . linspace ( 0 , 2 * np . pi , 50 ) theta_ , phi_ = np . meshgrid ( theta , phi ) r = ( R + .1 * ( np . cos ( 10 * theta_ ) * np . sin ( 14 * phi_ ))) xx = r * np . sin ( theta_ ) * np . cos ( phi_ ) yy = r * np . sin ( theta_ ) * np . sin ( phi_ ) zz = r * np . cos ( theta_ ) @kamodofy ( units = 'cm' ) def spherelike ( x_NM = xx , y_NM = yy , z_NM = zz ): return .1 * x_NM + x_NM ** 2 + y_NM ** 2 + z_NM ** 2 kamodo = Kamodo ( h_NM = spherelike ) kamodo fig = kamodo . plot ( 'h_NM' ) # pio.write_image(fig, 'images/3d-parametric-color.svg')","title":"Parametric surfaces"},{"location":"notebooks/Visualization/#map-to-plane","text":"We often need to produce slices through a volumetric grid of data. This may be accomplished through the use of volumetric grid interpolators equipped with default values for each of the input arguments. Suppose such a function has default input arguments of size (L), (M), (N), and output shape (L,M,N), then a cartesian plane will be generated if the user overrides one of these defaults (e.g. setting L = 1 ). @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN ) kamodo fig = kamodo . plot ( f_LMN = dict ( z_N = - 5 )) # pio.write_image(fig,'images/fig2d-map-to-plane.svg') Tip By providing appropriate defaults for the undelying grid structure, the interpolator author can ensure that the user can generate figures with optimal resolution!","title":"Map-to-plane"},{"location":"notebooks/Visualization/#multiple-traces","text":"Kamodo supports multiple traces in the same figure. Simply provide plot with multiple function-argument pairs. from kamodo import Kamodo t_N = pd . date_range ( 'Nov 9, 2018' , 'Nov 20, 2018' , freq = 'H' ) @kamodofy ( units = 'kg/m**3' ) def rho_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( dt_days ) + .1 * np . random . random ( len ( dt_days )) @kamodofy ( units = 'nPa' ) def p_N ( t_N = t_N ): dt_days = ( t_N - t_N [ 0 ]) . total_seconds () / ( 24 * 3600 ) return 1 + np . sin ( 2 * dt_days ) + .1 * np . random . random ( len ( dt_days )) kamodo = Kamodo ( rho_N = rho_N , p_N = p_N , verbose = False ) kamodo fig = kamodo . plot ( 'p_N' , 'rho_N' ) # pio.write_image(fig, 'images/multi-trace.svg') Note Plot types must be compatible for kamodo to plot different variables on the same axes. Kamodo can also handle multiple traces in 3D from kamodo import Kamodo , kamodofy @kamodofy ( units = 'g/cm**3' ) def f_LMN ( x_L = np . linspace ( - 5 , 5 , 50 ), y_M = np . linspace ( 0 , 10 , 75 ), z_N = np . linspace ( - 20 , 20 , 100 )): xx , yy , zz = np . meshgrid ( x_L , y_M , z_N , indexing = 'xy' ) return xx + yy + zz kamodo = Kamodo ( f_LMN = f_LMN , g_LMN = f_LMN ) kamodo fig = kamodo . plot ( f_LMN = dict ( z_N = 0 ), g_LMN = dict ( y_M = 5 )) # pio.write_image(fig, 'images/multi-trace3d.svg') Bug Multiple traces results in different colorbars which may overlap. More control over the layout will be available in future updates.","title":"Multiple traces"},{"location":"notebooks/Visualization/#interactive-plotting","text":"For interactive 3d plots, we take advantage of Plotly's in-browser plotting library. from plotly.offline import iplot , plot , init_notebook_mode To generate a separate interactive html page, use iplot instead of plot : # plot(fig, filename = 'sample_plot.html') #uncomment to render 3D interactive plot in this cell navigate to the 3d interactive plot: sample_plot.html . Alternatively, you may work with interactive plots directly in jupyter notebooks: # init_notebook_mode() # uncomment to initialize plotly for notebook # iplot(fig) #uncomment to render 3D interactive plot in this cell Note We have commented out the above lines because they do not render properly on the documentation server, but rest assured they do work!","title":"Interactive Plotting"},{"location":"notebooks/Weierstrass/","text":"from kamodo import Kamodo , kamodofy import numpy as np @kamodofy ( equation = r \"\\sum_{n=0}^ {500} (1/2)^n cos(3^n \\pi x)\" , citation = 'Weierstrass, K. (1872). Uber continuirliche functionen eines reellen arguments, die fur keinen worth des letzteren einen bestimmten differentailqutienten besitzen, Akademievortrag. Math. Werke, 71-74.' ) def weierstrass ( x = np . linspace ( - 2 , 2 , 1000 )): ''' Weierstrass function A continuous non-differentiable https://en.wikipedia.org/wiki/Weierstrass_function ''' nmax = 500 n = np . arange ( nmax ) xx , nn = np . meshgrid ( x , n ) ww = ( .5 ) ** nn * np . cos ( 3 ** nn * np . pi * xx ) return ww . sum ( axis = 0 ) k = Kamodo ( W = weierstrass ) k k . to_latex () k . W ( 0.25 ) fig = k . plot ( 'W' ) fig fig . write_image ( 'weirstrass.png' , scale = 2 )","title":"Weierstrass"},{"location":"notebooks/example_array_reshaping/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); import numpy as np x = np . linspace ( 0. , 3. , 30 ) y = np . linspace ( 0. , 1. , 20 ) z = np . linspace ( 0. , .5 , 10 ) xx , yy , zz = np . meshgrid ( x , y , z , indexing = 'xy' ) print ( 'x shape = ' , x . shape ) print ( 'xx shape = ' , xx . shape ) x shape = (30,) xx shape = (20, 30, 10) x1 = xx . shape [ 0 ] x2 = xx . shape [ 1 ] x3 = xx . shape [ 2 ] print ( x1 , x2 , x3 ) 20 30 10 xflat = np . reshape ( xx , - 1 ) print ( xflat . shape ) (6000,) newxx = np . reshape ( xflat ,( x1 , x2 , x3 )) print ( newxx . shape ) (20, 30, 10) ( xx == newxx ) . all () True","title":"Example array reshaping"},{"location":"notebooks/example_griddata/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); import numpy as np def func ( x , y ): return x * ( 1 - x ) * np . cos ( 4 * np . pi * x ) * np . sin ( 4 * np . pi * y ** 2 ) ** 2 grid_x , grid_y = np . mgrid [ 0 : 1 : 100 j , 0 : 1 : 200 j ] points = np . random . rand ( 1000 , 2 ) values = func ( points [:, 0 ], points [:, 1 ]) from scipy.interpolate import griddata grid_z0 = griddata ( points , values , ( grid_x , grid_y ), method = 'nearest' ) grid_z1 = griddata ( points , values , ( grid_x , grid_y ), method = 'linear' ) grid_z2 = griddata ( points , values , ( grid_x , grid_y ), method = 'cubic' ) import matplotlib.pyplot as plt plt . subplot ( 221 ) plt . imshow ( func ( grid_x , grid_y ) . T , extent = ( 0 , 1 , 0 , 1 ), origin = 'lower' ) plt . plot ( points [:, 0 ], points [:, 1 ], 'k.' , ms = 1 ) plt . title ( 'Original' ) plt . subplot ( 222 ) plt . imshow ( grid_z0 . T , extent = ( 0 , 1 , 0 , 1 ), origin = 'lower' ) plt . title ( 'Nearest' ) plt . subplot ( 223 ) plt . imshow ( grid_z1 . T , extent = ( 0 , 1 , 0 , 1 ), origin = 'lower' ) plt . title ( 'Linear' ) plt . subplot ( 224 ) plt . imshow ( grid_z2 . T , extent = ( 0 , 1 , 0 , 1 ), origin = 'lower' ) plt . title ( 'Cubic' ) plt . gcf () . set_size_inches ( 6 , 6 ) plt . show ()","title":"Example griddata"},{"location":"notebooks/example_griddata_timing/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); import time import numpy as np from scipy.interpolate import griddata def func ( x , y ): return x * ( 1 - x ) * np . cos ( 4 * np . pi * x ) * np . sin ( 4 * np . pi * y ** 2 ) ** 2 grid_x , grid_y = np . mgrid [ 0 : 1 : 20000 j , 0 : 1 : 20000 j ] points = np . random . rand ( 1000 , 2 ) values = func ( points [:, 0 ], points [:, 1 ]) tic = time . perf_counter () grid_z = griddata ( points , values , ( grid_x , grid_y ), method = 'linear' ) toc = time . perf_counter () print ( f \"Time to compute griddata interpolation: { toc - tic : 0.4f } seconds\" ) Time to compute griddata interpolation: 21.9338 seconds gs674-ddezeeuw Time to compute griddata interpolation: 21.9338 seconds cloud_dev7 Time to compute griddata interpolation: 56.5639 seconds kahala2 Time to compute griddata interpolation: 44.9300 seconds webdev --memory error","title":"Example griddata timing"},{"location":"notebooks/example_interpn/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); import numpy as np import scipy.interpolate x = np . arange ( 10 ) y = np . arange ( 10 ) z = np . arange ( 10 ) v = np . ones (( 10 , 10 , 10 )) sample_at = 8 * np . random . random (( 30 )) . reshape ( 10 , 3 ) for i in range ( len ( x )): v [ i ] = i #v sample_at array([[7.41077955, 4.57942655, 3.47985359], [2.70289376, 2.85958849, 5.71627146], [3.14025163, 0.3890023 , 6.01812666], [0.29310622, 1.0856275 , 3.01739223], [3.56317654, 2.6032635 , 0.6394823 ], [4.42988222, 7.01570625, 6.55717518], [4.52106349, 1.8368039 , 7.17544215], [2.1860096 , 0.33039227, 3.83512186], [6.99626711, 1.39500389, 6.12005517], [5.22419264, 4.19286725, 6.01297175]]) scipy . interpolate . interpn (( x , y , z ), v , sample_at ) array([7.41077955, 2.70289376, 3.14025163, 0.29310622, 3.56317654, 4.42988222, 4.52106349, 2.1860096 , 6.99626711, 5.22419264])","title":"Example interpn"}]}